S: So, statement, we already saw this I guess. Side effects, that’s where we use the mock. This is a combination of the stuff. And caching in, I also mentioned this caching in, don’t always specify when you’re using mocks. In this case, it makes sense for me to say, I create a mock. Just usual and then I create the SUT, and then I install this mock at this second statement, zip code equals zip code dot Q, forward the zip code and the mask, and then I’m setting the expectation whether I should receive valid with this zip code once [ones?  SS] and it comes true.  

In this case I’m constraining it once, very specifically because for caching, it makes sense. I call it once, that’s why I’m calling it twice. Zip code not valid. It will receive valid question mark. Second time, when it calls zip code not valid, it won’t even hit the method again. It’s basically a [cash resistant SS] value so it just returns the value immediately. 

We already saw this interface discovery, how in the diagram we were just going from one object to the next, and then how we replaced the objects which doesn’t exist yet. But the messages are being sent from one object because that object depends on the services provided by the some other object. So the object is outgoing message, becomes an incoming message for the object which is providing that service. So here we are working on something. It requires the collaboration of some other object, so you clear the mock, it’s something you need.  Something that you’re working on is the SUT. So you install this mock using dependency [1:01:56] as a constrictor, passing this mock, and you set the expectation: should help me. 

 That “help me” in red is actually the interface that you have discovered.  That’s the interface I need, and the return valid should be there, so it needs to return this particular string in this case. You can also-- the thing I’m working on, do something complicated-- in this case, do something complicated is the interface of the object I’m working on. I described this different layers here through this diagram. You have layer in layer-- a design, in system you have layer architecture, you have a technical domain. 

I have shown you several different technical domains. Like UI, ORM layer, messaging layer, web services layer, all those layers are technical domain layers. You will have a technology-specific lingo that you’ll be using all this: parameter has many for this terms, has belongs to, those are the relational terminology that you’re using in the ORM layer. You don’t want them to be actually going into your application domain. So we have adaptors and we isolate those-- if you want a greater ORM layer, ideally you don’t want that to impact your core domain; this could be an own separate modular package. The release cycle for this thing could be different from the release cycle for this. 

If it’s like [some SS] library, you don’t want to be under the mess here.  Somebody else’s, you know. [1:03:38] So it should not impact your stuff. So we have adaptors which Canword the concept from this technical specific layer to concepts to your domain-specific layer here. So the UA runs going in and out, so this also translation happens here also. And also you don’t want to be impacted with the terminology that your web services  or your payment gateway [gets SS] provides. They may be calling you something as a payment, you be calling something as a credit card, but you won’t have a-- conceptually, you won’t have-- you don’t want any mismatch, you want to stick to a terminology that everyone agrees within the team here so that you allow another translation layer. So those are the adaptors. Thats why this thing shows and you have the translation here, the window, the table marble, table, all those things, isolate the changes, the impact of changes is minimized. 

I also briefly went over this, why you should not be mocking third-party APIs, and having a thin wrapper-- in this case, you can see the adapted layer is a thin wrapper. Those interfaces are well-defined interfaces. The application objects are only calling into the adapted layer which we own. And we can mock these adapted layers since we own the adapted layer. The application objects only can talk to this mocks which will be much faster. Anything that goes back and calls back into your application code in this case, you can mock this because we actually own this. 

So in this case the application objects that are-- there is one interface in the adapted layer, which we are actually-- that particular class [thirty SS] can test separately as an integration test, because the adapted layer is [where you’re going to adapted SS] a third party API. And that integration test is what is going to give you the confidence: “Okay, this will work in the production system.” Because [1:05:53] to integrate with the third-party API. Anything from the adapted layer that is coming back into the application objects, we’re mocking it, because we own it. Now it’s time for you guys to do the TDD kata. 

If you don’t have a copy, I can just copy it from my flash drive and you can copy it.
[End video 1]
[Begin video 2]

S: Okay, I will actually recap the things I actually mentioned. You mentioned about the discipline when you listened to the video, right? You said as a cybil, make something as a cybil. 

How many of you use iphone apps? And how many of the building iphone apps have you really never touched or never used actually? There are a lot of built-in apps; it’s too simplistic. Some of the apps, like gamer video and a lot of examples I can give, which makes it as a Cybil, like you want to do something. What you want to do, the mapping from the thought to actually doing it, is-- the gap is like almost zero. That’s what a Cybil mean, making the user experience, right. 

And he also said he was talking about learning. How we go about learning about the problem domain. Speaking about the problem domain, solution domain, how the focus shifts from analysis to design later, but I just want to mention this entire thing he was talking about, was about learning. The TDD process-- when you’re doing TDD, it’s basically a learning process.  You’re learning a new domain; you’re leaning an API, you’re learning something new from-- when you pair programming with somebody else, you’re learning something new from the other guy. He’s showing you new tricks, you’re showing him your stuff. 

And then he was also talking about how the human mind thinks-- go step by step thinking, right? You can’t really overload your brain with too many things at once.  And that’s what happens, right? When you’re developing software, you’re given a problem. You have to analyze the existing problem first, you need to understand the existing problem. 

Can you give me an example of something he was talking about? Can you give me a problem statement, can you give me an example? Okay, there’s an example, there’s an example. I gradually increase my understanding of the system and then I make the examples executable. That’s what you really use. That’s one way to look at it. Like executable specs, executable examples. 

Shows you, okay, this many specs [ran SS], this many pass, this many fail, so you know exactly, you know-- if you run through-- in the right documentation format, it shows you-- uses a list of things to look at. And it’s kind of like a laundry list of things available in the system of executables, the documentation. Yes, basically it’s a learning process and you have-- he showed you the multiple representations, you go to an interview, and the interviewer gives you a problem statement and it’s all in textual thing that can be more ambiguity, but what if you-- that’s not your primary strength. If you’re a visual person, then you can work that problem statement, a visual thing. Like he showed you ties, things, this that. If you’re an algebraic equation kind of a guy, you do the algebraic equation and you solve from it. 

If I give you a factorial, I can give you a definition of what the factorial is actually. Or I can give you just a factorial like a mathematical representation of what the factorial is or Fibonacci is. And then whatever representation is your strong point-- if I don’t give you your strong point, and if you give a weaker representation, you need to be able to translate to your stronger representation and solve it, like a quote basically. That’s the problem-solving aspect of it. 

You went through one example of [beanie tie SS] and going, showing from the visual to the algebraic equation. That’s why they were actually going to end up in your quote. So the oral [0:04:00] was simplicity. Being able to simplify to external world is so cluttered and so many things are chaotic. Keeping everything simple that a presentation that you keep inside is always simple. So whatever you solve, whatever the solution comes with is always simple. So simplicity or it’s applicable to our TDD. 

Because basically when you use TDD, it’s a tool to build a system that is minimalistic. To minimize waste, that’s one of the concepts-- we don’t want to waste our resources. We don’t want to have waste in the form of having a feature that no one uses. It’s a waste. Waste of dollars, time, money, resources, everything. 

So, let me just move on to the-- my presentation. Before I give you the structure of how this thing is going to be-- I have seven different topics I’ll be going through, and they have several different subtopics. I’ll be showing you as I’m going through them. But before that, I want to get the three learning levels out of the way… I was trying to see if I could-- that’s fine. 

So basically you have three learning levels. First is the beginner’s stage like you were saying. I just do a copy paste, I don’t really understand. You don’t know why you are doing certain things, but you’re just reading some RSpec book or something else and you just do it. It just works but you don’t really know why you are doing things. That’s the level one, right. 

And then the next level, you really understand, okay, why you are doing things versus-- you are able to make decisions based on what the circumstances-- the constraints, whatever you have. You are able to make the right choice, given all the [data? Natives? SS]. You have a lot of choice because you know different ways of solving the problem and different ways of actually resolving issues, but you can choose the right one based on situation. That’s the second level. 

Third level is you’re not actually bounded by any of the rules and all the guidelines and beginners are given all the things. If you want to learn TDD, I’m going to go over them:  testing guidelines, this is what you do. Here is the TDD cycle, here is what you should do, this is what you should avoid doing, observing other developers doing all these things, but sometimes once you know why we actually have those guidelines and rules and all those things, it’s kind of like training wheels. Once you get used to it, the third level is you are able to improvise. You can keep all those things constant and you can actually improvise because you know what the goals are. So I’ll be going over the goals of what the TDD is and how we actually accomplish, attain those goals. 

Let’s first get this [classic mock SS] debate out of the way before I even show you the structure of the presentation. In classic TDD, if you watch Kent Beck programming, you will see he never uses any mock objects, no stubs, no mocks, nothing. He always uses the real objects. It’s the way he goes about this, it’s inside out development. He starts with the domain model and he gradually starts with one thing, and depending on something else and he keeps going and he meets some layer, next layer of your system, the next, and then now at the most boundary of your system, and then he actually eventually completes the entire system. That’s the classic way of doing TDD. 

Now the [building SS] around those different things which have come up, now we have stubs, we have mocks, we have all the different things, now I am a classic TDDer. I am a BDD-- TDD is great, BDD is great. I don’t want to actually get into the argument, but I’m going to show you what is statement [indication SS], what is behavior identification and I will just leave it to you, and I can give you certain guidelines as to when certain thing is applicable. 

To me, eventually, what the ultimate guideline for choosing whether the classic TDD or the mockist approach, is something has to make-- if the tool makes it simple, simplicity is a guideline for me to make the choice. I don’t want to get into this camp or that camp. If it makes my life simple, if it makes my code simple, simplicity is the ultimate thing that I actually aim for. I’ll show you all the different approaches, and it’s up to you whether you want to combine them both, or you consider yourself as a classic TDDer, or a mockist, or you want to be a BDDer, like all this behavior thing going on.

 So this is the structure for today’s boot camp, so simplicity is the first thing we saw is how to make complex things simple. I’m going to tie in the things he talked about as it relates to TDD.  So I’ll be spending some time on simplicity. And we need to know what the goals of our [test or dimension SS] is. Whenever somebody’s talking about [0:09:18], oh, this is so great, TDD, BDD, it’s all about what? It’s all about design. But there is more than just-- that’s not just the only goal. That’s a primary goal, yes, I totally agree. But there are three more goals related to test automation, and that really helps us-- as I was talking before, two days, three days, of de-bugging, we want to avoid them, having a way to have a digression test. 

There are other goals that we need to be aware of, and when we work on our project, we want to be able to accomplish those goals as well. And then we will see the basics of TDD. This is the TDD cycle, the red green refactor, how you go through the cycle that keeps repeating that becomes a rhythm, that has some subtopics on it that I will be showing you each subtopic as I cover those topics. 

And I found there are certain concepts which are applicable to both test code as well as production code, so I just grouped them together into intersecting concepts. There are some minor differences, like separation of concepts when it relates to testing, which is a little bit different. I’ll be discussing them. And then the basics of testing. This is when we will see how to write tests. Spend a lot of time on different problem solving techniques when we are actually writing the tests at the micro level. What are the different problem solving techniques.  And at the macro level, outside in, inside out. Those kind of different ways of actually testing your system. 

And then designing for testability, actually the design itself could be a one day work-up. Content, but I have just-- I’m covering just certain things, trying to hit the important points there, as it relates to testing. 

And the effective test automation. I’ll be going over some roadmap, how we can actually-- when you consider the entire system, it’s kind of like, simplicity the first topic is the big picture of what we are actually going to go over and then gradually we will zoom in to details of how you structure your test, what is the first test you should write, what is the next test you should write. And then you zoom back here to the designing [protestable SS] is more like system design. You go back up to the entire system and test automation and then you look at big picture. 

So we go from big picture, we zoom in, and then we go back, zoom out, and see how they all relate to each other. The first thing I’m going to be discussing is simplicity. 

So what is simplicity? When somebody says simplicity, what comes to your mind? There is no clutter. So here is one definition of simplicity. Sounds more like what is the Pareto's principle. 80/20 rule. If you spend 20%, you get 80% of the output. That’s your maximizing your stuff. And here is another definition of simplicity. You emphasize what is essential and you eliminate all the unnecessary stuff. Anybody know what this is? It’s a Japanese bento, it’s a lunchbox. If you see there are different colors, it’s well-balanced, it’s nutritious, it gives you all the different things you need, what your body needs. Each and everything in this box, there’s no waste. You can eat everything. Except the box perhaps. So there is no waste. And it provides nutrition, obviously we need. It’s half way it provides utility, it needs to provide utility for you guys. 

There is so many [0:13:42] like a word, some word perfect or something from Microsoft that have so many features that no one uses. There is so much waste, so many things that is not really the [0:13:56]. Here is simplicity. This is simple and elegant. This is like I said, the Japanese umbrella. And this is simple and elegant. It’s really complex and difficult to create. It requires four or five different people with specialized skills to produce this umbrella. And simplicity doesn’t mean that you-- something that’s very simplistic. If you just keep on watering down something-- everything should be made simple as possible but not simple. If you just make something more and more simple, eventually it will lose its value. If it does not have utility, then it becomes simplistic. 

It’s not simple actually becomes simplistic. But simplicity is the ultimate sophistication. How can I achieve this thing? If customer is asking you for this, and you give this, that’s the [status symbol’s 0:14:57] definition of simplicity. Snickers only cost $2, where the previous one costs thousands of dollars. But like sophisticated chocolate, this one is like $2. Customer-- you can have snickers even though you add something on. This is not simplicity. 

What is simplicity and what is simplistic? Simplistic is based on ignorance. Whereas simplicity is based on awareness. Simplistic is inattention; simplicity is about knowledge. And simplistic is about laziness, whereas simplicity is about spirit of helping. Deception versus honesty and sincerity. The ultimate guideline:  Simplicity is easy for us. Simplistic person says, Hey, customer, you can have the snicker, because it’s easy to create the speaker instead of giving you that sophisticated chocolate. Easy for customer is what simplicity’s about, whether from the user experience perspective, somebody designs the architecture, it makes the developers easy. 

I give you an API, I [twitter SS] an API, does it make the life easy, or is it like an Authorize.net API which makes everything complicated. We have seen software like that.  When it comes to software, simplicity-- everyone gives their own definition of simplicity. It’s kind of elusive. Something to strive for. 

But when it comes to software, we need something concrete. So this is taken from XP guide, I can’t remember his name. He has come up with this terminology, so I will briefly be going over them.  

So what is this TUBE? T stands for testable. If you write your test first, and you make your design testable, and you eventually end up with a system that is loosely coupled and highly cohesive. This allows you to achieve simplicity. 

And understandable. This is obvious. Understandable. To not just develop a two level, you are really an advanced developer and you are doing all this crazy meta programming, but is it understandable for someone who is coming in to work as an intern for instance? 

Browseable. You need to be able to find what you are looking for when you need it. If you don’t have this kind of quality in your software, basically you’ll be wasting your own time. Maintaining the software, new requirements come in, changes need to be made, and even you don’t know where to find the code you wrote few weeks ago. You are basically going to spend a lot of time on things you don’t like when you could be working on some cool things. 

Explainable. Understandable is obvious but explainable is something to others. “Oh, [that’s a Cybil as this SS] as the professor was saying.” Can you make it accessible to somebody else? Not at your level. Can you make it understandable to a child? Or to your mom? That simplicity, that characteristic in your software. 

Can you make it in your [0:18:30] in an airplane? So those are the qualities. And when it comes to software, the only thing I can think of, without giving a [rack SS], if it’s a framework, coding perspective, looking at the software, it’s very accessible. It’s not like Rails. 

I don’t understand a single line in Rails source code. I can download Rack and I can actually read this code, it’s accessible to me. It achieves simplicity. The API has simplicity. It’s not simplistic. It provides value. Lot of developers use it to make it run on several different web servers. All the Ruby web frameworks comply to this rack. And it’s continually progressing, several different versions coming out. I think the latest one is 1.4. So it has utility, simplicity, it has no bloat at all. 

It’s like the bento box of software. You use everything or you don’t use anything at all from this Rack spec. And it’s focused on doing one thing and it does it really well. After rack I would say Sinatra to some extent. Sinatra - it exposes complexity, so if you want to deal with complex things, you need to start writing complex things. 

The only thing that is going to be constant when you are developing, is change. That’s the only thing that can be guaranteed for tomorrow. You just finish the feature and you come in tomorrow either the feature is going to change or they decided to just scrap the entire thing altogether or you need to draw it out or modify-- you need to do major surgery. But to do this change, XP allows-- one of the values of XP is being able to make this change. Entire process is about being able to make this change. Entire process is about adapting to the change. 

Because our environment changes. Software actually interacts with the environment, and the environmental forces act upon the software, so we need to respond to the change. But we are afraid to change to it. How many of you have actually gone in and changed the code? Suddenly another guy comes in and says, “Okay you changed the code. My stuff is broken. Mine is broken because of the change that you made.  It’s [already implied SS].” Now your responsibility is to fix this issue. 

Impact of changes. You will always have this fear: What am I going to break? Existing thing, if it does not have any test coverage, you are always afraid to make any changes. So the TDD allows you to deal with change because it reduces the fear of making changes. If you have a set of tests, and you know, okay, I can catch them, if I actually break something when I modify, you can actually go and fix it. And then you don’t check-in anything until the test passes. 

And it also allows you to focus. Focus at two different levels:  at a macro level. CEO says, Okay, for this quarter, we have these themes, we want this, this, like three or four phrases, there’s along the list of three items, let’s say, for this quarter, that’s all we can get through for this quarter at least. 

And what do you do for the weekly? You break down those themes into stories. And then when you get down to code on a daily basis, what do you do to those stories? You eventually are going to have a class and then you’re going to have-- it should do this, it should do this-- a bunch of tests. It allows you to focus at the macro level and at the micro level. 

So that covers the simplicity. You know, there’s a lot of things about simplicity but how do you know you have really accomplished-- you have really achieved simplicity? It’s kind of like really difficult to pinpoint, okay, this has achieved simplicity. To some extent, you can say, this has achieved certain characteristics that is found in other system that has achieved simplicity. 

Now you’re going to look at the goals of test automation, which I think is really important before you will dive into it because you should know what we are aiming for by automating all these things. So the goal number one is specification. And the focus is design. This is what you hear form a lot of people: “Oh, RSpec is great and it’s not really about testing, it’s about design.” Yes. The primary goal is to [0:23:07] and you specify how the system should behave. 

The goal number two is also documentation. I went through the TUBE, explained about browseable-- the browseable relates to this. I need to be able to see. I need to find something, where do I need to go to find what I need to find. For this particular scenario, how does this system behave? So the [priority SS] focus is documentation. So I always have up-to-date documentation. I always can answer questions to the marketing team that come in and say, “Is this thing already done, or do we need to add in the new requirement that needs to be developed?” 

Goal number three is safety net. It’s like-- it provides a safety net and I need this to make progress. Without  the safety net you’re back to square one just finger pointing, each is finger pointing and everyone else, you made the change [incorporal SS]. You need to have regression. Bug comes in, ideally you need to write a test to expose the bug.  You fix it and not only that, now we have a test to cover that kind of thing, but we also need to start thinking about where else in the system can something similar happen? 

So that’s where you reduce the holes in your safety net so you have better regression test. So you can accomplish-- always make a safety net a little more stronger whenever this bug comes in. 

Then the next is number four. Like you said, the only thing that’s constant in this software is guaranteed to happen is change. Change is coming, it’s guaranteed. So how are you going to make your maintenance easier? So all this maintenance can be easy on yourself so you can work on cool stuff instead of just getting stuck on trying to debug existing thing. And trying to modify existing code. We have these four different goals, and some of these goals-- for instance, documentation, when you want some documentation, you want the documentation to be very very clear to read. And how do you write documentation which is going to be clear? Is it going to be concise? Concise versus something clear, there is a force. 

Something which is concise can become very cryptic and you can’t really understand what is going on there. Always keep this in mind. So documentation is more important than having something really concise, especially when other developers are going to have to maintain your code. 

So the first goal I said is specification. Let’s see. What is this specification actually? What does it mean to specify something? Kent Beck said, “Specification is the goal of TDD, not validation.” Validation is a side effect of doing TDD. You’re not really trying to write an [exhaustive  SS] amount of tests. 

Kent Beck-- there was one simple programming problem involving triangles. Kent Beck wrote like 8 or 10 tests, but the guy was like a QA guy; Robert Binder wrote 65 tests. So when do you stop?  It’s not about validation. It’s about specification; it’s about driving the design of my code. Developers’ intent while you’re doing TDD: you’re trying to drive the design of your code. When I have enough confidence in my code, I have a safety net which I think things which are more likely to happen; I’ve handled it, just stop writing tests.  It’s not about writing 65 tests for a simplistic problem. 

Here is an example of specification. This is a design of a car. Just by looking at this, what can you say about this specification? What is it actually trying to tell you?

A: [Kind of a size too big SS].
S: Yes. I can answer the question, What is the height, for instance. It’s giving me this. What is this [repair or of SS] from bumper to bumper, from this to this. What is the height inside? Somebody with 6 feet, will they fit in here?  I can answer what, what is the height of the internal passenger seat? What is the width? What is the height? What is the distance between these things?  What what what. It’s all about what.  The specification is all about what. What is the distance between this and this? 

It does not emphasize any HOW the engine is going to operate, how much power is going to be in the transmission, it does not say anything about how the transmission is going to auto, is going to be manual. It does not say any of those implementation details. It’s all about the specification. Only about specification. It gives you specification. Those are the only things I can answer here. 

This is now the customer explained it, and the problem that I understood it this way, how the analyst designed it, how the programmer wrote it, how the business [councilman SS] described it. Documentation doesn’t exist, that’s one of the rules, there is no documentation here. It’s missing probably. And what [0:29:37]. Nothing. And the customer [0:29:44] train or something. How it was supported. Virtually nothing. Marketing advertisements has allowed me to focus on this. What the customer really needed was this. [0:29:58] 

So how do you-- whatever the customer is saying, they’re giving you the behavior of the system. How are you going to specify the behavior of the system? How are you going to document the system? How are you going to support it? How are you going to meet the business needs? We have all these different goals that we need to achieve. We need to specify things so that we don’t lose the message. 

Now let’s-- I just briefly mentioned about the problem-solving things while I discuss the simplicity. I just want to go over this quickly. Somebody gives you a problem. The first thing you do is-- okay, I’m not-- I don’t know what this is. I’ve never heard this before. First you need to look at the problem domain. When you’re doing this, you’re actually focused on the problem domain. And the solution domain is the solution system actually. That’s going to be the actual algebraic equation or something that is going to define-- it’s  a well-defined specification. There is no ambiguity in the language there. 

To end up like what we saw in the previous slide. There is a solved problem. And when you’re in the problem domain, you’re basically in the analysis-- analyzing the problem. I’m trying to understand the problem. You give me a problem statement. Okay, can you give me an example? Another example. Can you give me another example? And I write down the example. And I keep going, all the different [mory SS] cases and stuff. I understand enough about the problem, I’ve done enough analysis. Now I need to understand the problem. I can cheat. I can look up google or whatever. Eventually I need to solve the problem. That’s the design, design aspect of it. 

So your mind is actually-- if you focus on one thing, you should focus on one thing. If you’re doing analysis, make sure you’re analyzing and understanding the problem correctly. And then when you’re going to the solution domain, make sure your design or your solution to the problem is either going to solve the different cases. That’s going to answer-- when you start writing your executable examples. There is an intersection between these two. This is the specification actually. That’s going to connect the problem domain to the solution domain. That’s going to address the requirements. That’s what the specification is. 

There’s a lot of confusion about what the specification is. There was even a keyword specify in RSpec actually. Specified behavior, but you’re actually bringing this problem domain solution point. So again, I’m just covering the priority goals. Specification-- what is this-- how can we design this? Solution domain. Solution space. Specification is actually bridging from the analysis to the design. Analysis as such, you don’t do too much of up-front analysis. To some extent, you do just enough to actually start writing some tests, to give you that momentum initially. 

So that covers-- now we know what the goal of test automation are. It’s not just the design. Yes, it’s a primary goal, but we do have other goals like this one that’s going to help to maintain documentation and all that other stuff.

 Now, we are going to go to the basics of TDD. So this is relating to different subsections. First we will see the TDD cycle, and then we will see how this TDD cycle repeats itself, or now again it becomes the rhythm of TDD, when you’re proceeding with a pair and when you’re coding and how that’s going to work. And then I-- this lower level, the micro level, and then we’re going to go back up and see kick starting the TDD cycle. Big picture, entire system as such. And maintaining the TDD cycle in the context of a project.

S: So let’s look at the TDD cycle. This is just one cycle. No repetition. Everybody must have heard this thing before. You’re failing in a test, make the test pass, refactor. So you’re in red state, make the test pass it’s green, refactor, it should be green.

 There are three simple rules when you are doing this. Write no production code except to pass a failing test. This is a very simple thing, but if you are not very disciplined, you will start writing code-- production code that is not required to pass the test, or you don’t have a test first that demands you to write more code. Write only enough of a test to demonstrate a failure. If you’re just too enthusiastic, “I have all these different things and I’m going to handle them all in one test.”No. Just focus, again it’s about focus.

 Test one thing and one thing only. Each test should test one thing and one thing only. Focus. Write only enough production code to pass the test. Not too much, just enough. Just enough to pass the existing test. Your test should force writing more production code.  These are simple rules but if you’re not aware you could violate them and you’re not doing TDD anymore. 

It’s something else and you could get into problems and you’re stuck and you don’t know how to get the cycle going. You cannot get a rhythm, a TDD rhythm. Once you get in the hang of TDD rhythm, then it will become a part of your behavior, you just apply them without thinking. So write a failing test, and we already saw-- one other goal is to be able to maintain this after. 

Always adding another thing. Always make the diagnostics clear. How can you make your diagnostics clear? I expected this, I got this. And make sure you specify what the expected value was, get the error message, and this is what you actually got. So when you’re actually going, look at the error message, can you immediately go and fix the problem? Or are you going to be like spending a lot of hours. If the test does not provide the value of being able to pinpoint, of “Okay, this is where I need to go in and fix,” there is no point in having a test. 

You are back to square one again. Debugging for like two days, three days, just to figure out what the problem is. And you don’t know what the problem is. If you’re in a situation where your test doesn’t tell you where the problem is, then there is no value in having a test. So you have to make the tests that you write the diagnostics clear for yourself and for others. Make the test pass, refactor. 

Always improve the diagnostics of your own test. How many libraries, APIs, gems, have you used and the error message it gives-- the user doesn’t really know what they need to do to recover from the error message. What is the point? There is no value in that kind of thing. 

So let’s first look at the test first programming. We want to write the test first, not after the fact the code has been written. If you already have written a code, if you write a test, you’ll be green already. It won’t fail. And your code will actually dictate what your test structure should be. If your code is shitty, then the test will also be shitty. Both will be really difficult to maintain.

 You want to write the test first so that you’re designing a system that is testable, so that you achieve this [height equals zero SS] equation. Use [culpable SS] system. This is how the traffic light works. Green, yellow, red. Green, yellow, red. So we are going from green to yellow. And then yellow to red. And then red to green. These are the traffic transitions. 

Let’s look at them in detail. Going from green to yellow. Yellow, I mean-- see the red green refactor is actually kind of like a misnomer. Red, green, refactor is not the name of a color. Doesn’t make any sense to me. So in order to actually understand what are the right things to do and what things you need and why, I have actually-- this was done by one of the XP guys so I have actually taken those things from his blog post. So basically it goes from green to yellow. Yellow is basically, you made a syntax error. You’re not failing for the right reason. If you’re failing for the right reason, that’s a red. Green is all tests are passing. 

So let’s take the first condition. If you’re going from green to yellow, all the tests were passing. That’s what green means. Now you add a new test, but you’re yellow. Which means you made a syntax error. You need to correct the syntax error. So it will fail for the right reason and then you can go back, so that’s okay. If you make a syntax error, just correct it and you can keep going. Going from yellow to red, you corrected the syntax error, now the test is failing for the right reason. That’s fine.  And then when you have-- going from red to green, what it means is-- once you have a failing test for the right reason, you go and write the production code just enough to pass that particular test. Minimal.

 Always minimalistic system. Simplicity’s what we are aiming for. So the test now passes, that is fine. Let’s consider another scenario where you have a blinking green. 

Blinking green. You’re green and you’re green. Let’s say you have like 10 tests running, it’s all green, and you see some code duplication in your tests. You clean up. You’re going to be green. Or it could also mean-- in that case it’s okay. Or it could also mean you wrote a test, it passed, but the bug is in your test. The system does not really satisfy the behavior, but the test that you wrote is not correct. So it’s saying green. In that case, green to green, in that case, feature is complete. You can also think of it as, if your test is buggy-- there is no test to prove the correctness of your test. That’s one thing. And it’s like a false, a negative basically, when the test is actually not testing anything and the system is saying it’s already implemented something, you basically have to fix the bug in your test so that it fails. Another scenario where the green can happen:  Let’s say I give you a factorial for instance. And you’re so familiar with the factorial you just write the very first test, the abstract thing, it just handles all the thing, because your dominant learning mode is the algebraic equation and you knew this thing well, you know, you just type in the obvious implementation. 

Next one I give you the boundary condition, the test is not going to fail because the abstract solution already handles the boundary condition. So you go from green to green. In this case what you should you do? Because remember, you don’t have a test to test your test. How will you prove the correctness of your test? Because it’s not becoming red. So you go to your production code and break the boundary condition. Find the boundary condition and add some other invalid value so that it breaks for the right reason. Only by knowing the test failure I know it’s actually testing the right thing I’m expecting it to test. If the test doesn’t fail, it’s a feedback basically. If the test doesn’t fail, it’s an indication of, “Okay, something is wrong. I need to do something.” Always we need to have a failing test. Because the test does not have another test to prove its correctness. Only way we test the test is manually. Manually by checking, okay, it’s failing for the right reason. Is this failing for the right reason? You do it once manually and that’s it. 

Test is bad, we already saw the test could be buggy, so you need to fix the test actually. The code may be okay. Now we saw how we go when we go in the production code, you break the boundary condition, so the test fails and you can actually make the test fail, go from red to green. And we also saw when you are refactoring, you have a lot of tests, you see a lot of duplication, you put a lot of things into your setup, and you clean up all your things, and you may be using a let block, and all that, so you always refactor when you are green, and when you are ending the refactor, you should be green. 

This concept is so simple but people actually miss this. “I know this is very-- I’m red right now, but I know this is a very simple change; I know it’s going to work.” You make the change, but it still doesn’t work. You’re red, you’re red, “I’m refactoring.” You cannot refactor when you are in red right now. You can never refactor when you are in red. You should always start the refactor when you are in green. When you finish your refactor you should be green. Again, it’s all about the focus. 

If you read the refactoring book by Martin Fowler, he says either you add a new feature, or you refactor. You don’t do both at the same time. Either you clean up the code or you add a new feature. Do one or the other. Don’t do both at the same time. But the concept is so simple, yet people don’t focus. They try to do multiple things. You’re adding a new feature and at the same time you’re refactoring. Don’t do that. 

Again, it’s about having the discipline. Having the focus. Being able to focus one thing at a time. Never ever refactor when you are in red state. So, if you have a flashing yellow, what does it mean? Yellow is-- what yellow stands for? You just made a syntax error, you just correct the syntax error. So, yellow, blinking yellow, you just correct your syntax error. Either the test passes or it fails for the right reason, so that you’re back to the one of the state where you can make progress to the next state. 

What about this red? Red, blinking red. The blinking yellow is like a traffic light. You slow down. If something is happening, you cannot proceed further unless you fix your syntax error. Blinking red in a traffic light, you actually stop and look. It’s-- this color is all about feedback. It’s giving you feedback. In red, red is flashing, you added a test, it’s breaking. You did something in the production code to make it pass, it’s still red. Still red. Red for a long time. Our objective is always to go from red to green very very quickly. If you’re red too long, for too long, you’re doing something wrong. You’re taking much bigger steps than you really need to. You’re over-confident. 

S: There are exceptions. Like if you’re upgrading the Rails Aspect, [you need a project SS], you will be in red for a long time. One, two hours, you’ll be in red. You cannot avoid it. But I’ve seen situations where you are write a ton of code, and the developer is so confident he can make it work, but it’s not working. You’re basically-- you have several different alternatives to solve a problem. You take one approach. That approach is not working, so you need to back out to the state, the previous state. If you check-in often, whenever you are green and you accomplish certain levels of [same SS] features, you can actually go back to that state and take an alternative path and you can try a new thing. You don’t know if this is going to work. You’re analyzing a certain alternative to that particular problem, that problem domain. You understood the problem, your solution is being tested; whether it’s going to work or not. If it’s not working, you need to back out and try a different solution. 

You need to-- it’s a way for you to actually-- this blinks always indicate that you need to stop and do something different. It breaks the TDD cycle. When it’s all green you have to go and mutate the production code, or you have to think what exactly is the context of this green flashing or this yellow flashing. Yellow flashing is straightforward: you just fix the syntax error and move on. Whereas if it’s red you need to think about more, “okay, I need to roll back, like do a git checkout, let’s go back, I don’t think this is going to work out. Maybe I’ll try programming with [Toefl SS] and maybe you’re right, let’s try your alternative solution and see if that will work. 

S: Now let’s consider the reverse direction of all the traffic light flows. So in this case I go from green to red, and then red to yellow, and then yellow to green. So what does it mean going from green to red? All the tests were passing, you added in a new test, and you’re red. Can we say it’s okay? If you’re failing for the right reason? It’s okay. And you’re red-- you’re failing for the right reason, but you now have a syntax error. 

What happened right now? Think about this one. What do you do when you have a failing test?  You have to write your production code. You made a syntax error in your production code. Fix that syntax error in your production code. Maybe your configuration is missing. You did something; you need to fix that to get past it. You need to do something. And then going from yellow to green, you made-- you basically fixed the syntax error and you will either go to red or something, or if you fix the error in your production code, you fix the syntax error, then it passes, that’s also fine. So, I want to really emphasize this thing. When you’re failing for the right reason, you want to get to green very, very quickly. 

I always want this feedback loop. I want very quick feedback. Whatever I’m doing, is this working? Write a failing test:  your focus is on WHAT the system should do. That’s your only focus in the problem domain. [That factorial. SS] You focus on the WHAT aspect of it. That’s when this red state is happening. And the green is when you’re trying to make it pass. That’s when you’re actually worried about, okay, is my solution going to work? Now you’re worried about design. The red was about analysis and specifying, whereas the green was about making something work. And if you keep on cleaning up, refactoring, you can stay in green as long as you want. But you want to minimize this thing. You want to minimize the time you are in red. 

So to reiterate it from a different perspective: write a failing unit test. That’s how we start it right. What should my system do?  Fly over some golden clouds at this particular speed, this is what I expect this thing to behave. You want to write a failing test. Start with the failing test. Start it right. You make it work. When you make it work, you are even-minded actually. You just want to write the minimal amount of code, the lazy way of-- minimal amount of code in your production to get the existing test working. You want to make it work.  

But you’re really even-minded actually. You don’t want to do more work than is really required, that is demanded. And then you make it right. Now you need to clean up. Just because it’s working, doesn’t mean that your design is good. You need to actually make sure you don’t have any duplication and you’re applying the good design principles, and your code is clean. 

Make it right. And then you can worry about making it fast. You have a [0:52:57] solution, what was in production, and your boss comes in and says, “This is not performing well.” Then you need to worry about making it fast. Change the algorithm. Now we have a [suite SS] of tests. So even if you change the algorithm, you can actually make sure you don’t break anything.  And then later you can worry about making something really pretty, all the [UI steps SS]. 

Because the previous steps allows you to-- okay, how does this alternative evaluate with another alternative? You take different alternatives, different routes, something-- one of them works out. Everything works fine. So that’s the TDD cycle. 

S: Now what is this rhythm of TDD? The TDD cycle is going to repeat. It just is not going to stop just because you write one failing test and you made it pass. Again, you need to write another failing test, pass, it’s going to keep repeating over and over again. So the rhythm of TDD. 

I already explained-- at the micro level and the macro level how we actually break down the themes of the stories into a laundry list of things you need to actually write and get it working. 

When you’re doing this, and you’re working with a pair-programming partner, it’s like ping pong. It’s called ping pong basically. I write a test, you make it pass. And then you write a test, I make it pass. And we keep going like this. Establish like a rhythm. Sometimes you are familiar with regular expression and I am not; that could break the rhythm. “You know what? I will let you drive because you know regular expression. I’m just going to write the test for it.” And he’s going to implement it. So it depends. 

On the [paid SS] programming, it’s a learning process. He knows something, I know something, you learn from each other. It’s a learning process. Again, we saw how often do you check-in? When do you check-in? It affects the rhythm. If you are in red for too long, your rhythm is broken. Red, green, refactor, red, green refactor, red, green, refactor. Establish rhythm. 

If you’re red red red red, that’s broken. Your rhythm is broken. You don’t want to break your rhythm. If you get to a point where you have sufficient functionality, you check in as often as-- you think okay, this is-- it’s one atomic function, I’m going to check it in right now. So what does it allow me to do?

 Two different paths. You take one path, you end up in red. You need to come back to the fork again. So you can try a different solution. If you’ve already checked-in the code, you can always go back to a working green version and try alternative version. “Gabriel, okay, he knows better than me, I’ll use this algorithm.” That’s the rhythm of TDD. 

S: Now we’re going to actually zoom out and look at the big picture. Kick starting the TDD cycle. You go into a project and you’re just not-- the very first time you go and start writing code, it’s not like as if you can start writing unit tests right away. You need to maybe interact with the external web services, you have some messaging thing. You have to maybe interact with a legacy system, you have an existing database that you need to interact with. So it’s like a [whole other SS] system. 

Somebody comes up with architecture. But the very first thing you do, is you test a walking skeleton. That’s what is called as a walking skeleton. It doesn’t do much. Okay, I can actually talk to it anyways. I can put a hello message into the messaging queue. I can say hello to [0:57:22].  I can do-- insert some [0:57:23] into the legacy database or something. I can talk to a legacy. 

The entire thing, the very first iteration-- it’s called iteration zero, doesn’t do anything. It’s a skeleton. You’re just able to establish, okay I can do all the different things. That’s what you focus on. We’re fleshing out those technical details, configuration things, and all the different things.

 Okay, in testing [soundbacks SS], okay, if it’s a Paypal, you will be having the different accounts. You’re doing all the different things that need to be done. How do you maintain the TDD cycle? [Alarm] You need to be able to listen to your test. How do you listen to your test? It’s not going to play music like this. But the pain, you may be having a pain in writing your tests, and that pain is actually trying to tell you something. It’s trying to tell you something, but are you able to listen to your test? It’s saying that your design needs improvement, there’s something that needs to be done to improve the design. 

Usually I ask, what makes TDD difficult? Writing tests itself is difficult. That itself is trying to tell you something. It’s a symptom of your bad design. You have to actually-- how are you going to deal with this design? Long setup code, code duplication, all kinds of different things, but you always have to look for the structure of your test and see what it’s trying to tell you. And not just-- you start writing tests, test one, two, three, four, and you just keep-- you’re just so at this very-- you’re focused on just only the one test at a time. 

You need to be able to actually zoom out and be able to see how does the previous test relate to the test I’m going to write now?  How does it relate to the big picture? Because sometimes the test that you write-- you may just delete it. It was just a way to actually get to another test which actually is much more appropriate and you would retain that test. Sometimes you had to delete the test. It’s not applicable anymore. 

So I will be going over when you actually delete tests. Which scenarios are you deleting tests. So you always need to know, how does the existing test fit into the whole scenario? And are you listening to the feedback that the tests are giving you?
[End second hour]

