[Continue video 3 ("TDD bootcamp part 2") at 0:45:37]
S: You can only go through this public API. There are methods available that acts upon this state and provides certain services to other objects. And there is another object and this object cannot do everything by itself. It needs to collaborate with other objects. It has to send messages to other objects to do its task and return some result, do-- it has some indirect output or something. 

You follow the good OO principle, you encapsulate, you follow the encapsulation, its abstraction, all those things, well-designed objects. If you have all the well-designed objects, you also need to make sure the communication between those objects are also well-designed, like for instance, you always depend on the something which is more stable than your abstract. Don’t depend on concretions like solid principles and all those things. So you have-- you cannot have just one or two objects. Basically your domain model will be having multiple objects, so they’re web of collaborating objects. It’s just a graph of objects. This guy is independent of everybody else. Everybody else uses services provided by this guy, and this guy’s services are used by these two guys, and this guy is eventually using this guy, who in turn uses all this. So you have all these different communication paths. Look at all this communications going from one object to the other. In a well-designed system, you’ll be very careful how you design this messaging between systems. 

If you see some Rails code project, you’ll actually have this, this, this, it’s like a violation of law of Demeter -- foo.b.a.x--  you just keep on chaining them to the-- it’s a train wreck basically. In a well-defined interfaces-- if you have well-defined interfaces, they provide some services. That’s all you need to know. The public API-- you just use it, that’s it. Don’t just keep on grabbing data and chaining calls forever. Unless you have very good reason to do so. So if you design those services provided by the objects properly, you will think about what is this interface that I need to provide? I need-- I want to fulfill my responsibility as some object b here that does not exist yet. 

Maybe Karen is working on it right now. But I need to write my object a. I cannot wait till she is done. We are working in parallel. So I can replace it with mock. As long as we have agreed upon a well-defined interface-- okay, we have agreed upon this thing. She has told me these are all the arguments. I’m going to pass through, and she’s going to give me this result set. I only program to that interface. The mock is basically going to comply to that interface. When she is done, I can use the real object. 

The integration test has to use a real object. It can’t really use a mock when you write a customer test. It has to integrate all of the layers together. So it’s a way to discover the interfaces. I want to discover this interface. What is the role that this object plays? And then I need another service from another object. I gradually discover all the different interfaces I need. 

Okay, Gabriel is working on some other thing I need from him also so I have another contract with another team. And I start using another mock to replace Gabriel’s module. And so on. So you have all these different interfaces. These are all the web of objects collaborating through roles. Not just interfaces-- you want to find the roles that objects play. The main point of using roles is basically-- it allows you to compose objects in different way. 

Let’s say I have a person object. Person object can play the role of a student, it can play the role of a son, daughter, all these different things. But you’re playing a different role. As a student, I have a certain set of responsibilities. Study, pay attention, all of these things. Those are all methods, responsibilities; those are all methods. Played by that particular role. And if I don’t attach it to a person object, I can take that particular role, student role, and I can give it to a dog object. It can be a student now. Without even changing the system, I can pass a dog object to the system. I compose the run-time behavior object composition will be different. Behavior will change. Because of the duck typing, everything will just work. You need very minimal-- even if you need to make any changes, very minimal changes in the code is required. 

S: So CRC. In XP we use CRC cards for doing design; there is no UML modeling, all this thing. It’s a very agile way of actually designing it. Here is a game engine. This is a candidate class. These are all its-- the column on the left is all the responsibilities of this candidate class. It displays game state. This is a role. Again, this is a responsibility. This is the role which collaborates with the game engine to accomplish this particular responsibility. 

These are collisions, all these things. So this is a candidate class, and these are its responsibilities. And these are its collaborators. Instead of CRC class responsibility collaborators, you are to start thinking in terms of-- move toward thinking in terms of roles, responsibilities, and collaborators. Renderer it could just be a role. Animator is a role. Collision detector is just a role. This way I can actually swap different implementation of collision directors. I can have a fake collision director where I don’t really want to incur the expense of running a long-running test. I can actually have a fake animator and it‘s just not really doing a real animation; it’s just faking something. Makes my test run faster. 

So you are basically designing for testability. You can plug in different things, you can combine different objects in a different way to accomplish-- customize the behavior of the system. So if you think about this, Unix is based on the same principle. There you have pipes. You have cat, you have ls, piping where you can redirect output to some file. You can use those small utilities that’s focused on just doing one thing, but when you chain them all together, they accomplish a much bigger task.  We want to do the same thing in OO programming. We want each object to be focused and very cohesive and highly cohesive and loosely coupled. 

So if it’s loosely coupled I can combine them just like Unix chaining together. I can combine these objects in different combinations and I can accomplish-- I can satisfy a new requirement that I didn’t really think of when I wrote this code. But tomorrow’s changes that’s coming in down the pipeline I can actually satisfy the requirement using existing objects. I can reuse them in different contexts. 

So let’s consider. Okay, we have our graph of objects. Let’s just assume we have all these communications-- it’s not like haphazardly going to each and every thing and just like spaghetti-- it’s well-defined, well-designed services. Each object provides services. Let’s just focus only on this guy. See what’s happening-- if I want to test this guy in isolation, I have some services being used by this guy. I have some outgoing messages. I have two guys coming in. In order to test this in isolation, I have to actually-- it replays this entire thing-- actually environment, it’s going to actually resemble as it-- these guys are providing-- if I need something from some other object, I’m going to replace those guys with something which is going to be like a fake, that’s going to run faster in actual test environment. In actual production environment, it’s going to use the real objects. So if I just consider one object, I have incoming messages, I have outgoing messages, and I have messages sent to itself. 

So we saw indirect input, direct input, indirect output, direct output, and now the different combinations. What is this message-- the object is sending a message to itself mean? If it’s an incoming message, I have provided some services to others. It’s in my public API. Everybody can see this. It’s a well-published API. All of these outgoing things are invisible things I made-- depending on some other component’s result that’s going to come back. For instance, if this is a shopping cart, let’s take a concrete example: shopping cart. And somebody-- customer just selected, in the shopping cart they put a product into it. They said “add” and they provided a parameter: “okay I want to purchase this book,” and they said “I want one book in this.” One book is in here.  Eventually, they say, “I want to check out.” To the shopping cart. But the shopping cart in the checkout, what it needs to show them is, how many books did you put in your shopping cart, what is the price, what is the quantity. It also needs to show how much you’re going to pay for the shipping and handling. Shopping cart-- that’s not the job of the shopping cart to do the tax calculating. Tax calculating is somebody else is going to do it. That’s the dependent-on component. Tax calculation needs to know what is your state, what is the weight of the item that’s going to be shipped, so I can calculate based on that geographic location, I can give you what the tax calculation is. I can just give you, okay, this is the amount, what is the total amount you want to charge tax for, this state, this weight, here is your tax. Somebody else is going to give-- this guy is going to ask, this is my total weight, this is the state where this customer belongs to, please give me the tax. It’s going to ask him. This is the indirect input that it requires in order to go on actually provide the line-item display that the users can see from the browser. 

That’s another concrete example of indirect input required by this guy in order to fulfill his public API. Services he’s providing an API. So this way, I can actually stub out the tax calculation. I don’t really need to go to the database, to find the geographical location, six percent is the rate at which I need to calculate tax. I can actually fake the entire thing. So my test will run faster. So we already saw the test-- when you actually write a test and you’re going to actually test a particular object, it’s going to depend on certain services of something else. If it’s a parallel development, some other team is working on it, you don’t even know that it even exists-- it doesn’t exist yet or someone’s working but you need them. What are these? You need to have your test written for your thing that you’re working on. That’s when you actually replace them with mocks. Those things will also be-- you have more control over it, as long as you have well defined interface-- you can actually complete writing the test for your particular module. So, any questions on the messaging thing that we have already seen before we move on to testing guidelines? You always use the API first. Use the front door first. The public API is also called as the front door.
A: Will you be giving us examples that [0:59:11]  Will you show us an example?
S: Example for?
A: For interacting with third party service, let’s say you’re using SUT or-
S: That-- I have a diagram for that toward the end of the thing. I have a diagram which actually goes over it. 
A: [0:59:35] External resources.
S: Yes. Anything that deals with external resources. I’ll tell you whether you need to stub or mock, when you actually have to integrate, how we will do it-- all this-
A: So the summary of this section was, If you are having any third-party interaction, just mock that?
S: No. Don’t mock. Mocking is all about-- coming to the mock with the entire section on mock, you don’t mock a third-party library. Because you cannot drive the design of a third-party API. If you have authorize.net, paypal API, you cannot mock them because you have no control over what they are doing. But what you can do, you can stub them. You have more control over them in your unit test. In your unit test, you will stub them. 

But for integration test, you have to actually write a test which is going to hit-if it’s Paypal, it’s going to hit the test send box. Just to make sure your system can interact with their external API as of now. When somebody comes-- if I go into a project, somebody gives me a Braintree, say here is a Braintree API, I don’t know how it works. I want to learn the API. So write tests. To make sure your understanding of how the API works is valid. Once you have the test that’s specific to that version of Braintree, where Braintree 1.0, Oh I have learning tests. That’s more like integration test. What is the value of having that? When Braintree comes up with version 2.0, if some of my tests fail, I need to fix them. Upgrade them. Because my code eventually will fail because it’s different from those assumptions. Whatever changes I make for that learning test for the API, I need to make those changes for my dependent object, that particular layer. You actually need to have a very thin layer. Your domain model, you’ll have a very thin layer of adaptor that’s having well-defined interface that you have control over, that you can mock, but the thin adaptor will adapt your domain model to the external API calls. So this way you insulate the changes from the third-party changes, they have their own release cycle. I don’t want my department to be impacted by somebody else’s schedule. I want to have more control over it. That’s why I isolated it. This is like anti-corruption layer. This way I decide when I want to upgrade Braintree. When I run all these integration tests, if all of them pass, Oh, no problem-- it’s backward compatible. Just because he says in the documentation, Read me, it’s backward compatible, I cannot rely on it. Because I don’t want to risk my system blowing up, customer not being able to purchase item on the site because of third-party, I cannot blame it on them, right? So I need to have the testing that needs to give me the confidence of okay, If I upgrade this, if all of the test passes, I can guarantee none of the changes will impact our code base and we can go ahead with upgrade process. 

So we can pinpoint, okay what is going to be the impact of changes? Instead of saying, I don’t know, maybe we’ll upgrade and see if everything-- I don’t really know what the impact of changes will be because you cannot really determine, unless you have a test suite that you can run automatically at your command when you want to run it. Then you can pinpoint, we have so many tests breaking, some are serious things we need to really look into it, we cannot upgrade right now. No. We need to hold off on it. We cannot upgrade right now. You can make the decision. I’ll show you that layer and I’ll be talking about them then.
A: I’m still confused. So you’re saying all the real service [1:03:22]
S: Your question was, How do I deal with external web service. External -- you don’t mock, you stub them. You stub them in your unit test so your unit test will be faster. Because you should not be going over the network in any of your unit tests.  You should not waste resources. 
A: I’m just confused about mocks and stubs-
S: I’m going to actually-- I have a 60 minute session on stubs and mocks. And then it will be more clear when we revisit the topic. The one other thing is, challenges, all this material-- it’s not linear. But I’m trying to gradually build you up to it, so everybody’s at the same level. Once I start discussing those things, everybody will understand what I’m talking about. Otherwise I will be jumping the gun too soon. Which I don’t want to do.

 Okay, right now let’s look at some testing guidelines, like Gabriel mentioned, during lunch I know some of these things. Yes. Because you know what you’re doing. These are guidelines to get you started. They are there for a reason, but if you have to break them, do them for a valid, sensible reason.

 The first one is, don’t modify the system under test. I’ve seen this thing-- a lot of people actually-- we have a lot of tests, for instance, in one of projects, and suddenly some test started breaking. So what he did was, he went into the production code and he put this if Rails.env  equals test, skip this line of code. So what he did was, the system under test is basically a production code, and he’s changing the behavior of the production code to be different in the test from what is in production. If we start having these kinds of conditionals, band-aids, in your code, eventually it’s going to create more misery than solve any problems for you. So you have to be very careful when you put all these band-aids in there. But Rails already gives you test mode, you have all access to this thing, you have a test.rb. It’s like a specific configuration for testing. You have specific for production, and you have specific for development. So you configure according to environment, but don’t change the source code and put band-aids in there, because it’ll cause problems later. 

Keep test logic out of production. Basically same thing. Band-aid everything you don’t put like if Rails.env -- like we say do this otherwise we do something else. It’s just going to get a lot of problems down the line. This also can kind of-- we discussed this thing over lunch. Gabriel was talking about this.

 Effort versus responsibility. Commensurate effort versus responsibility. What does this really mean? It’s effortless. It falls down. Because of gravity it just comes down. It’s so easy. How much effort does it expend?  Not much and it doesn’t weigh that much. The thing is, when you have a production code and you have like four lines of code, you should not be having like a 10 or 15 lines of test code to test the four lines of production code. You’re expending so much effort to actually test something as simple as four lines of code. You’re doing something wrong. If you’re doing it, do it for valid reasons. “Okay, I know I’m breaking it. I’m doing it because I want to increase the communication. I want the communication benefit to be emphasized. That’s why I’m writing four or five tests for just four lines of code. That’s fine.” Or my confidence level in that code is very low. This is very critical part for my revenue everything generates because of this purchasing part of the code. Even if there are just four lines of code, I don’t want my purchasing system to have-- I don’t want to lose money basically. You have lot of things to lose-- monetary-wise you’re going to lose a lot, then it makes sense. 

You always think about, okay, if it’s just one line for instance, Rails has like one line, one active support uses a lot of very high level APIs. If you can just write one line of code, it makes a lot of things easier, even tests, if you know how to use the right test API, you can just do one assertion, you can just test everything instead of trying to do four lines of code. Always weigh the effort you’re spending on testing something versus what you’re actually testing. 

S: So now we will come back to this TDD, BDD, behavior driven development, all these buzzwords. So what you did in the morning exercise is basically a state verification. What you did was-- the method was basically a stateless method. You provided some input, you got some result back, you verified that state. Okay, what was the state at the end of the particular call? Was it what I expected?  That’s what you checked. 

So in the setup in this case, in your case, the setup was creating some object. It was for some of you, you created an object and you had-- you called that method on it. Some of you had like a class method, so you did not have to create any object. And in the exercise phase, you actually called your sequence or number or those things, passing in the value. That’s when you exercised your Fibonacci, which was under development. You discovered the API. “Oh, I want to call this as a number, I want to call this as a sequence.” What did you verify? The result that was returned back was the direct output. From the Fibonacci thing. And you checked the verification. Result should equal equal zero, one. You did a state verification. That is an example for a state verification. All this thing is grayed out because-- all these are invisible, you ignore them because it’s a direct input, direct output. 

And Fibonacci is the only method you were testing. It was not a cluster of objects. This is state verification, and this differs from behavior verification. What is the behavior verification? You have an object that’s calling this object, this in turn uses services from this object, as well as this, this guy is sending messages to these two guys. If you see this, these are all black. I don’t care about the state. What is the state? This is the black box. I don’t care what is inside this object. My focus is only on the messages that is being sent between objects. In Behavior verification, I care only about these messages. That’s what behavior verification is all about. You are not really checking what is the result that is coming out of some method call that you just made. 

Here it is. This is what it looks like. You still have the setup phase, you can setup, create objects you need. In the exercise phase, you invoke a certain operation on the SUT. See what happened in the invisible part. You cannot see this thing. These are all like indirect outputs, behavior. These are all messages going out. Outgoing messages. Initially I showed you: everything can be boiled down to incoming messages or outgoing messages. Outgoing messages says it’s dependent on component. This, this message could be going to a messaging queue. This message is going to a database, this is going to a web service. You want to-- if the charger just completed the purchase, you want to charge them. This is the customer’s credit card. Please charge them so that it goes into a certain queue and gets processed. It’s asynchronous. You cannot view it. Confirmation email is sent. “Here is your purchase.” Email has been sent to the customer. You cannot really see them, but you can assert on those messages and make sure, Okay, confirmation email was sent to the customer after the purchase was successful. The credit card charges was made after a successful of purchase. I did charge the customer, so I am not losing money. Because it’s important for me to charge the customer, especially when I am going to ship the product. So I have to assert on the messages. Okay, it did send the email, should receive confirmation email, something like that. “Should receive” charge customer, authorize.net API; that’s going to interact with the authorized.net API. That’s where you will be using all those assertions, behavior. So I already talked about the front door. Front door is the public API. Always use the front door, which means always use the public API where you will be doing calling all the methods, where state verification or behavior verification, you’ll be calling those public APIs. 

What is this back door verification? Back door verification is basically you just bypass the setup method, you directly go into the database in this case. You setup some data here, fixture, that you need, and then you exercise your system under test. You’re not actually-- depending on the result, this guy is returning. You’re actually bypassing-- you’re using the back door to verify, oh okay, is this what I expect this thing to be in-- state? Sometimes this actually solves certain problems with-- most of the time, state verification and behavior verification is actually covers like 90% of all the cases. 

So back door is used in very few cases. But you still need to know what this is-- this is available to you. And one other testing guidelines is you should not have any if statements, loops, nothing. I said it has to be so simple that even an intern who’s coming in could look at your code and say, Okay, I understand this. I get this. 

So if you cannot have an if statement, then what can you have then in your test? That’s where we have guard assertion. Instead of having an if for something, you create a guard. If condition is called a guard. Basically if sometimes if you don’t have a guard condition, your program crashes. Maybe you don't have a guard condition, that’s what we say. In this case, if it’s so important to you and you have to assert, have to have some kind of thing, make it as a guard assertion. So if the built-in API does not give you, just write your own and make sure you have that library well-tested so you can reuse it everywhere.  

And the custom assertion is-- some of the domain-specific thing-- for instance is not coming out of the general RSpec API. Sometimes you have to write your own custom assertions that are applicable for your business domain. Custom assertion or even the domain assertion.

A: What’s an assertion, exactly?

S: Very good question. Assertion-- let’s take a step back. Assertion is basically-- assertion can take any arbitrary expression. We will see a lot of different matchers in RSpec, what assertions look like. What kind of expressions you can have, whether you can just have boolean expression, whether you can have float point comparisons. Floating point numbers, they’re not precise. If you give me like $10 and 99 cents, and if I have $10 and 99 cents, if I subtract, but they’re still not equal to zero. So you have a delta assertion. You have different kinds of assertions. It’s basically stating a post condition. What should be the behavior of the system at the end of the exercise phase. 

[stop video 3 ("TDD bootcamp part 2") at 1:15:32]


[Continue video 3 ("TDD bootcamp part 2") at 1:15:32]
A: So in the Fibonacci exercise, it would just basically be-
S: The result.
A: equals-
S: Yeah, that was assertion. Let’s say I am writing a calculator program. I’m adding two numbers. 5 + 5. Let’s say I’m not even writing a test. How would you manually check the output is right? 5 + 5 = 10, but you’re checking the output. You’re doing a puts or something. You’re printing to the output console, you’re looking, oh, 10, that’s correct. See how you manually verified it? Manual verification? If you automate the manual verification, using an API, that’s what an assertion is. You are asserting the end state of this thing has to be something. It has to be valid; this is the post condition. It has to be valid and if this thing is valid, then I know the test passes. Otherwise it doesn’t. And you also pass in the messages and you actually give-- this is the expected output. I got this, that’s why I failed. You always specify in the message, be clear. Otherwise it will be difficult to find out where actually to go in the code and fix it. Always see from other guy’s perspective of how can I make this diagnostics clear. 

Custom equality assertion is like you have a person object let’s say. Person object, how can I say-- Toefl, right? Person-- can I compare Toefl person object with a Bala person object? What would I check? What is your social security number? You’re not going to give me. 

So, if the social security number is the same, can I say the person is the same object? For my business domain, I can say that right? Yeah, it could be possible. So you define your own equality for a business object. What is equality? We have like equal, equal, equal operator in Ruby. That’s what you use in the switch statement. In the switch case, you can use object. And if those objects are-- you can compare objects, if you define them, oh, if the SSN is the same as Toefl, you need to identify your-- you can come into this country from Bulgaria, it’s okay, you can come in. Okay, I identify you; I let you in. So your custom equality assertion, if you give two objects, person one and person two, and you have defined your custom equality in your object, triple equals operator, then you can use your custom equality assertion. You’re just passing an object instead of-- you just use equal equal, to  compare integers. For objects, you have to define your own equality. Because it has identity. 

So, the delta assertion also as I mentioned, if you’re floating by like 1099, 1099, do a 1099; if you do a minus, it will still be like .0001, and it will fail, so you have to say delta I can do two digits, three digits, it’s okay. They’re close enough they’re equal. 

So this is available in the built-in API. 
Use the front door first. It’s like a public API before you consider the back door way of doing things because public API is there for a reason, for everybody’s consumption. And public API is well-tested. Anything that is private, the messages which is getting to self, I showed you, object sending a message to itself means it’s calling its private method. Some other external object can call a private method by using a send in Ruby for instance, but you should be careful of touching all the private parts like private methods as well as the data structure because it will be changed without notice. It’s-- will make your test brittle basically. 

Here is another guideline which is like verify one condition and one condition only. You should check one  and one thing only. What if I want to really check four different things? Maybe it’s-- your domain specific assertion, maybe you need to write your own one liner things so it can avoid duplication across all your different tests. This customer, that customer are the same, how would you know? You define your own customer equality thing, loyalty program or something, you define what it is, those terminology. So you can reuse, you just make four or five assertions keeping it repeating everywhere, raise the level of abstraction, make it as a one reusable assertion, so it just becomes like verify one condition thing. 

And then test concepts separately, if you’re testing the, for instance, UI, very good example would be like looking at some of the code of people write in Rails, if you have a controller for instance, some people do render views inside the controller. Not only they test the controller assigning this thing to object, they’re actually response should have this, this, again, that’s violating test concerns separately. You should not be doing, that’s not a good practice. Views, if it’s a web service and if it’s important to test, test them separately. Controller, just focus on testing the controller layer. View layer is different layer, have a separate test. It’s easy for you to maintain. 

And keep tests independent of each other which means, you cannot share the test context so much that the test context impacts the other tests. There is a dependency-- if you’re sharing contexts, and one of the tests fails, and if the other test is depending on the test context left by the previous test, then you have a dependency. You cannot run the test in any order you like. It becomes a sequential kind of a thing which is not desirable.

A: I had a question about that. You mentioned earlier that if something breaks and changes, you should have one test pointing to it.

S: That is called defect localization. If one thing in the production code fails, because of one reason, I only want to have one test to fail.

A: So my question is, if you have a core class, say as a custom identity comparison, and that somehow gets broken because you introduce a new field, lots of other things might break. If suddenly two objects aren’t equal when you’d expect that they would be, other than setting dependencies and pre-requisites in your tests, is there a way to keep one thing breaking when one chain breaks you might have something fundamental break which would break even through your entire system. I’ve done it where I make a change, I’ve seen like 15 or 20-- all of the tests go bad from like a syntax error. It’d be really nice to have kind of one thing pointing saying this really basic thing instead of having to look through. I’m not sure how to do that other than putting dependencies on tests and saying, you know my test can’t pass if this test doesn’t pass. Is there another way?

S: Very good question. So the concrete example would be you said it’s a customer object?

A: yeah, what I was really doing-- something that represented magic numbers. This macro we were talking about. Code that used it broke because I hadn’t had a default returning a null. It was throwing an exception if you asked if for something, and there wasn’t code that happened to test. That’s why I had 5 or 7 things break.  And finally I just had to look because I knew I’d changed only one thing, and I was like, I bet they’re expecting. I looked at the old implementation. I returned null… I had 5 tests fail instead of one and I don’t know how-

S: So, to me it seems like what you created is kind of like a value object. It’s like a currency, it’s like a money object?

A: I didn’t understand what I was replacing because it wasn’t fully speced in tests, so it was returning none or null instead of throwing-- an exception.

S: That’s fine. So what-- have you read the design by contract-- are you familiar with the design by contract thing? It’s Object Oriented Software Construction by Bertrand Mayer. It’s like a huge book. It’s a classic. Basically, you created an object which is kind of like entity-- it’s like a basic thing which can be used in lots of different places, kind of like a [huge SS] thing that can be used-
A: And I broke it.

S: Why did you break it? Because you changed the contract. You changed the contract.

A: Yes, because I didn’t understand the original contract which wasn’t tested and so-

S: The assumption you made, was this context was implicit; other tests were depending on the contract, but you changed it. It’s going to impact all the things which are depending on it. How can you prevent this from happening? I’m going to give you a minute to thing about this. You know what the problem is? You know what the objective is to-- minimize the impact of changes. You want to insulate. You want to localize. Wherever-- we want to get close to where the breakage happens. How can you do that?

A: I did put a test in immediately after for that, to say, Oh, I need to specify that. 
S: Contract. Yes. Make the assumption explicit. If it fails where it’s supposed to fail, then you can easily fix it. If the contract is broken, immediately fix it.

A: But it was one of 5 or 7 tests that failed. The other ones were confusing. That one was pretty straightforward. 

S: Do you remember the component test I was showing you?
A: With the progressively larger-

S: Yes, I had SUT 1, unit test 1, SUT 2, unit test 2, and then I put the SUT 1 and SUT 2 inside component 1, and it had a component test for it. This component test is what was missing for you because this guy has to be-- if this guy is independent of everybody else, he has to be well-tested on his own. His components are well-tested on his own. You have to run that guy’s test just alone by itself. If this guy breaks, he can immediately fix all that so that none of the other guys will actually fail. 

A: So if I’m hearing you correctly, you do advocate structuring your tests or running your tests-

S: Make your assumption explicit. You have an implicit assumptions, you haven’t codified. You don’t have contract tests. 

A: So if you change the contract-
S: If you change the contract, you
A: So that you can identify it quicker and-
S: Exactly. 

A: Do the tools in Ruby RSpec or others, do they let you specify that or do you have to set that up outside and run RSpec on this before you run it on that? Do you have to do your own-

S: It’s kind of like running the unit tests for different layers. You know the seven layer architecture? ISO thing?  How it’s structured: the bottom most layer does not depend on anybody else above the guy. Every guy above is depending on the below guy. In your case, that guy was here. That layer needs its own test. 

A: But do the tools help you segregate?

S: Yes, of course. You can structure on your own. You know how I learned to do it this way? Because I read a book called Practical Object Oriented Ruby by Sandy Metz. She shows exactly how to write this contract test. How to make this-- she’s a professor at the University of North Carolina or something. How to catch the false positive, false negative, when the mocks go out of sync with your code base, it also answers the same questions. How do you keep your mocks in sync with your objects? It’s all in your contract test. Read that book, she has some very nice code examples.

A: If you change something, and all these other tests-

S: Because you have dependencies. The arrows are coming in. If you change the contract, I said it’s a well-defined public contract. If you change the interface, it’s like you upgrading your Braintree API from 1.0 to 2.0, if you break the public API, of course your clients are going to break. 

A: What could we do to handle-- let’s say that object is being used somewhere-- can you use it somewhere else? Does it test for that object?

S: Let’s say I-- you actually have developed a module to go to Braintree and you have named this method as Charge and it takes some amount. It’s going to hit the credit card Braintree and charge the customer and return true or false. I’m-- depending on this method called Charge. You are taking one parameter which you is returning true or false. That is the contract between you as the developer of the web service and me as an application developer working on some domain-specific logic. We don’t have any tests like you were saying. All my tests were passing, everything is dependent on the Charge method passing and getting true or false.  What you do instead of returning true or false. What you do is-- instead of returning true or false, you start throwing exceptions.  Because you’re doing throwing exceptions now. All my tests are now breaking because I’m doing if. Charge do something, otherwise [rendered SS] [1:30:27] saying, “I cannot-- am not able to charge you, blah blah. Enter your credit card again.” But the customer has already been handling-- you’re throwing some exception. You broke that contract. So what I’m telling you is, if you have a well-defined interface, you’re independent of everybody else. Everybody else is depending on you, so you need to have tests to make the contract explicit. Think about interface in Java. What does the interface in Java mean? It has a return type, it has a method, it has a signature. Anybody who implements it has to obey the protocol. In Ruby we don’t have interface. The closest we can come to is to come up with a module where you will have a test. Where if I provide a positive thing, you should respond too. When you write a test for this thing explicitly, you will write a test to make sure you respond to charge method with one integer returning true or false. Must return true or false. If you break the API, that test will fail. Then immediately I can localize the defect and I can-- okay, this thing has failed, that’s why everything else is failing.

A: Does it also come down to how you order the test? It seems like-

S: You should not-- you should be able to order the test in any way you like. There should be no dependency on the order you run the test. That’s what keeping tests independent means. Isolation.

A: If there’s several test cases that are dependent on the interface, on the contract, and there is one test case based on the contract, it seems to make sense that the test case that tested at interface contract run first, so that allows you to-

S: Yes. 

A: Is there any way for you to structure? Because if there are so many test cases that are based on-

S: No, because it’s kind of like a layer architecture. I am going back to a layer architecture.
A: So that means you test it at that level first?
S: She’s at the boundary. At the Braintree API. That’s her API. Everybody else uses her service, so that it has to be tested thoroughly first. That layer has to be-- you have to make sure.  Everybody is depending on her. [Add-ons] is going into the public API. 

A: Let’s say that I call the third-party service and then they are not testing it and I’m just stubbing that service and that’s some mystery, I shouldn’t do-- something is wrong right? Their service has to be tested first?

S: Yes. If you’re publishing an API and they’re giving you API documentation, you’re programming according to that. You can change something and if it breaks something, it’s their fault basically. You won’t upgrade. If they come up with a later version, if it breaks your API, you don’t upgrade, you just found out, you cannot release on that schedule; it’s too risky.

A:So if it uses third-party API, then you should always have a test suite version for that API?
S: Yes, you should.
A: -- use it-- run a test before you make any changes-
S: You should. What is the very first thing you do? You do-- maybe you go to a company with-- there is internally-- there is web services, there is external web services you need to maybe use a Paypal API, use a Twitter API, Facebook API, but you don’t know how that API works. A lot of things mentioned in the documentation is wrong, especially in Facebook. So what you do is, you write a test to prove that the documentation is wrong. Suddenly if they fix something, your test will fail. Which means they have fixed something, your test is depending on those quirky things, you can actually see what the impact is. You’re in a better position to actually either decide, I’m going to upgrade this or I’m going to just ignore this, I’m going to ask for more time from my manager. You know what to do. 

A: Basically, if you’re testing any of the third-party service tests, actual behavior-

S: You need to actually have integration. Integration tests.  It’s going to hit the test sandbox. It needs to have a live thing-- that’s how you know the production code is going to work. Unit test is in isolation.  You use stubs-- test locally. Because you still want to make sure-- cucumber test is only going to give you the confidence that all the layers within your application, your system, can work together. How can you make sure something is going to work to the external system, you need to have integration tests as well, separately. Without using any stubs or mocks hitting their test center runs like mocks, the sandbox for instance. Like authorized.net has like test sandbox mode, you can specify your test API key and all that. 

A: You referenced the Kent Beck videos-- 
S: Kent Beck video Pragmatic Programmers.

A:  -his examples are using-- he’s writing a wrapper around Tokyo Retirement, and it shows him doing this. He has some documents, he’s basically sending bytes to and from the servers all in Java which may be kind of hard to understand-

S: It’s like an integration test basically-

A: But he shows, he’s basically building and showing that this is how Tokyo Retirement works.
S: I highly recommend you watch that video, because that’s the kind of thing you want to do when you’re-- you have to interact with the external services API, or even the internal services. Some other team is managing. 

A: You can get the first-- it’s unedited-- you can get the first 10 minutes free. Google for Kent Beck TDD-

S: If you go to the Pragmatic Studio, they have pragmatic screen cast.

So, minimize untestable code. I’m just going to keep nailing this point until you actually say, okay, I get this. What does-- we saw the hard-to-test code. What is hard-to-test code? Threading, transaction, GUI components, asynchronous messaging thing. Doesn’t really come back immediately. And you could also make your own life difficult by having looping statement, if statement, all that, so you want to minimize the untestable code. There are a lot of techniques dealing with testing, multi-threaded programming, GUI components, having [humble SS] dialogue, we won’t see them now. There is a way to do that, but what is within your control is keeping this test so simple it does not require any tests. So how to you minimize untestable code? Don’t have any if conditions, no switch statements, no looping through it like you did range.each and you’re doing all that-- don’t do that. If you cannot do that, what can you do then? What if we really need to use the loops? What is the alternative? 

A: Data-driven tests?

S: That’s one-- in a Dot.net, yeah, that could be something similar where you could use, make the data-driven kind of thing. What I would do, extract all those things in their own test utility methods. Have tests to test them thoroughly and use the API. And we provide the data. 

A: Like a metal testing layer that does the dynamic-

S: I’m saying try to raise the level of abstraction. If you have to provide a range and you need to -- let’s say you need to do all that-- provide a range and do all that. Can I just have a method that takes the range and it does the check for you? And you name the method accordingly and it returns you either true or false so that it passed or not. You’ll be happy, right? I’m in the same company, I can use the library now if you have test covering all the scenarios, you make sure that works across all different possible conditions. So I can reuse the test utility method. I can benefit from it. Data driven thing is one way. I’ve seen the dot.net guys actually do it in the code itself by providing-- it’s like a fitness kind of a thing. That’s one option. 

Having your own testing library is another option. The point is to actually-- don’t be too clever in your test. Make it very simple. Simplicity is the most important thing in your test code.

Now you spoke to your customer, and you are very clear on what they want the system to do, you’re clear on the behavior. Now you have these themes and you have stories, and you put the stories into some product where it allows you to check out the task and start working on it.

 So starter test. The question is, what should be the first test to write. You have a long laundry list of things to do. You have like 5, 10 things, right? And you just have described-- you’re describing your class and yeah, it should do this, it should do that. And you have like 5, 10 things in there. So how would you go about picking the first test to write? Now we know the structure, now we have the requirements. Now we have to write the first test now. So how do you pick the first test?

A: Simplest.
S: Simplest. Anybody else agree with Toefl?

A: If any story comes, then highest priority thing you take first, and whatever-
S: Highest priority first. Anybody else on priority? Who is for priority and who is for simplest thing here? Let’s say I pick the simplest story. The story is being broken down even further, 5, 10 tests. I’m talking about at that level you’re looking at the code editor, and you need to pick the test. So I already know I am working on a high-priority-- charging the customer is going to bring me the money. I’m asking you what is the first test to write. He’s going in the right direction. That was also right, that’s like one level above. 

A: Definitely a happy path-- you don’t want to-
S: Happy path, okay. Anything else?
A: Just go down to the really base level like the class, just make sure that has the right attributes, properties-
S: Yes, actually you write a test that is so trivial that it does nothing. Return a blank string, return a zero. That’s what we did in the example we had. We started with zero. I just happened to give you that first sequence which was zero zero. What is the point of actually doing that? What did you get out of it, writing the first step which was returning zero? 

A: Encouragement.
S: You set up all the different things that you needed. Starter is all about getting started. Giving you that impetus you need. Describe statement, oh, I need to have this. It’s not Ruby, Spec.rb, it’s RSpec. Learn-- you learn how to use the framework API, you learn the syntax, you found all for the documentation, okay, this is how you actually use the API, this is how you have the blank string. Oh, it is a method that takes a string and okay. And you did the most trivial thing. Why did you do the most trivial thing? That’s the quickest way of finding-- getting feedback. I always want feedback. It’s all about, okay, my idea is here, I am implementing my idea. Is my idea right or not? 

Only running the test will tell you whether you are right or not, by looking at the green. When you get to green, okay you are right.  I’m finding that belief, okay, you are going in the right direction.
Now I’ve returned the first test, how do I go about picking the next, second test? Okay, I feel good, it should return zero for zero. How will I pick the next test?

A: Next incremental-

S: Yes. What do we gain by this? I’m slowly learning about the problem, I’m slowly gaining confidence over time. It’s a learning process basically. It’s a learning process, getting accustomed to the tools you were using, getting accustomed to the API, getting accustomed to the problem. 

You slowly gain confidence. More confidence you gain, you don’t have to take baby steps anymore. You can take longer steps. As long as you can get to green quickly, you can take bigger steps if you want. 

It gets progressively more and more difficult. Eventually you have to solve the real problem, you have to get to the abstract solution. So that is the starter test. You know how to pick the first test to write. 

What is the one step test? One step in a sense-- always pick the next test-- it takes one step closer to my overall goal. One step closer to my overall goal. Overall goal is I want to write a Fibonacci sequence. I want to be-- calculate a Fibonacci sequence of any number, that’s my ultimate goal. But I want to get one step closer to my goal. What is the minimal thing that I’m comfortable-- I know I can pass this test quickly. I know I can write this test very quickly and make it get to green. I will come and I pick that. I pick that and I write it. And I make it pass and I move on to the next one. 

So the learning test, we already saw here we have an external API. I don’t know how the Braintree works because we did not write this API here in house, and the documentation says this is how it works, but I don’t really know how it works, so I’m going to write a learning test. The learning test is what is going to validate the assumption, the documentation that it’s lying or that it’s telling me the truth. You will find all the bugs in the external vendors documentation and you retain this learning test over time, and it provides value when you are going to upgrade. Upgrade the external library.

[Stop video 3 ("TDD bootcamp part 2") at 1:45:10]



















