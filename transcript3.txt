[Continue video 2 ("TDD bootcamp part 1") at 1:00:02]
S: So that’s the maintaining the TDD cycle. Being able to listen to the test and actually-- consciously apply good design principles. Magically-- If you’re just using TDD, you cannot say okay, the great design emerged out of this, emergent design happened and it just happens to me. Might happen if Kent Beck is coding, he has three decades of experience, but we have to consciously listen to the feedback the tests are giving, the structure that’s emerging, and we need to consciously apply good design principles. That’s the maintaining the TDD cycle. 

So that completes the basics of TDD. I’m going to go over some of the concepts which is common to both testing and the production code. Probably we’ll-- once I complete this, we’ll stop for a lunch break if you want, it’s almost like 12, and then we’ll work on a simple fibinachi TDD thing so that you get used to the TDD cycle. Work in pairs. 

S: So what are the intersecting concepts that are applicable to both? Yeah, bugs. Whenever you say “bugs,” you think of-- only the production code can have bug now. Actually, the test can have bugs. So you need to be aware of that so you can avoid them. I’ll be giving you some guidelines of how you can avoid them. 

So what is these bugs? How can they happen? It’s impossible, right? That’s why when you have a false negative, the test is passing, when it’s supposed to fail. That is a bug right there. And false positive-- test is failing when it’s supposed to pass. So when you’re using stubs and mocks, let’s say Shika is on one team and I am working on another team. And I’m actually mocking out whatever-- because I mock only the API I own, we are on the same company. I am going to use whatever the API we agreed upon. I’m using that mock; it’s passing. And she went and changed the interface. My mock passes. It says hey, you are fine, because I’m using a mock. Whereas the real object, in the real production will fail. So that’s a false positive. Now my test has a bug in it. So I need to update the test. If you have an integration test, it will catch the integration problems. 

[What if you don't have failing integration test in this case? Discuss it here]

So I will be giving you the guidelines on how you can actually-- getting the situation where you have bugs in your code. One thing I really want to emphasize is your test, your automated test, does not have a test to prove its correctness. So what it means is you have to keep your test so simple it does not require a test. Simplicity, again. 

Lower maintenance costs if you keep it simple; it’s documented, if you can quickly go and fix the bugs. It’s called defect localization when something breaks and exactly-- it breaks because of just one thing. It should break only one test when one thing goes wrong. Otherwise if hundreds of tests fails, I don’t know why, what exactly needs to be fixed.  

So defect localization is important to prevent high maintenance costs. If something is giving you good diagnostics, like I expected this, I got this, I know exactly where to go and fix. It’s easy for me to maintain. It lowers the maintenance costs. Again it ties back into the goal that we have. 

S: Code duplication. Everybody here knows how to recognize code duplication and then refactor, and clean up your test code or your production code. But the thing is, being able to actually-- the data duplication is also important. Data duplication is also a form of duplication that you need to be aware of. Don’t use magic numbers like 5, 10. What does it signify? What 5? Okay, if a premium customer is charged something, specify that. Make it a constant. Declare it in one place. 

[Find Kent beck's book example for data duplication]

So data duplication is also-- you need to focus on it, even in your tests, you need to make sure you’ve defined them and its intentions are expressive-- names of the methods, constants that you’re using, classes. 

So, hard-to-test-code. So one other thing I asked is what makes testing difficult? What is some examples of hard-to-test-code? 

How about threading, transactions? GUI components. There are so many things to make testing difficult. You don’t want to make testing difficult for yourself by adding code which is complex. You want to keep everything simple. You want to minimize complexity in your actual test. 

Communicate intent. Don’t just name your variables like a, b, c. What does the variable signify? Or just t, temp, even if it’s not an temp variable. It has to have intention in the names, variable names, constant names, method names, the class names. When you communicate intent, you’re communicating with yourself in the future. If you want to maintain later, you need to know what you were thinking when you wrote this code. This ties back into maintenance costs. That particular goal we have. 

The same thing is applicable to production code also. I want to treat the test code just like I would do the production code. I want to have expressive tests, I want to specify things, I want to only say what, I want to hide all the implementation details of how I am going to do certain things. I want this thing to be expressive. It’s kind of like telling a story. 

Separation of concerns. Same thing here. Just like in production code, if you have a well-designed system, you have a layered architecture, where the different concerns are all separated, in test code also I want to have separation of concerns. In a sense I want to-- if I’m testing a specific thing about logging or something, I want to only focus on that particular thing. I don’t want to test five different things, make five different assertions and things which are unrelated. So it’s a little bit different in that sense, from production code. Separation of concerns is more like, your focus and clarity. It’s about more clarity. Just keep your test very simple, because you don’t have another test to prove the correctness. 

How can you improve quality? All the things we saw before, making it expressive, keeping it simple, being able to actually see where exactly things are broken. Defect localization, so I can quickly go and fix it. It also improves the quality of your test code itself. Having no code duplication, no data duplication, all the changes are localized. You just go to one spot and you just change stuff there, so that you don’t have to go to so many places to change things. Makes your maintenance easier. You don’t have that complexity. Should be easy to write and maintain. 

Frameworks like Rspec give you a lot of built-in assertions. If you’re familiar, you can just use them. You just specify what your system should do. And it’s already tested. Those assertion messages are already tested. For your particular domain, you may want to write your own utilities and stuff, but you still need to test those utilities. Should have separate tests so that you keep that as an external library. So that you make sure that’s well-tested before you start using your domain-specific things. So those are the intersecting concepts between testing and coding. 

Now, I think I will stop here because right now we have four sections and then basics of testing. We’ll see how to write tests and all that when we come back from lunch. So designing for testability, effective test automation, and then we’ll be working on a TDD Kata and stuff. So any questions so far?

A: I’m wondering when you describe these concepts, can you show some code examples? Because just by showing the heading and then you talking about it, it doesn’t-- I mean it’s nice-- it doesn’t-

S: Yes, I have a lot of code samples when I actually cover the stubs, mocks, and stuff like that. And the TDD cycle, I’m going to give you that Fibanachi factorial and things, and I’ll be actually going around. See that’s more like-- what you do-- the daily-- the things you go through-- like working for 8 hours doing TDD-- the kind of things you are aware of and the things you actually do-- is more like a decision-making process. What you focus on. How you write a test. What test to write first. Conceptually, you need to know. How do you pick the first test to write? Am I doing the right thing? What is the next test to pick, for instance. Once you have a series of tests, how do you maintain the existing growing test suite. Those are the things which will actually help you. Not-- Yes, having code can illustrate some concepts. Definitely. I will be having some sample code and also I’m going to let you work on some things and I’m going to be helping you. It’s not about the actual problem itself. I want to focus more-- I can even give you the equation, solved problem. Okay, this is a problem, this is the solution, this is a solved problem. I want you to focus more on the red, green refactor, how the thing feels when you’re working in pairs. Some of the things like the goals, like documentation and stuff like that, it’s kind of like-- I just showed you a rack as an example for-- I would say, to me that embodies simplicity. You just have to do git clone and start reading the code. If I have time, I can do all that. I think you have a good point but in the interest of time, I actually want to see how much material I can get through and we can actually go back and look at some code samples to illustrate those concepts.

A: -some of the concepts. If you have examples, it will be easier to-
S: Understand-
A: -for example you mentioned data-- duplicate data-
S: Code duplication everybody knows, 100%-
A: But data duplication.
S: Data duplication, yes.
A: But how do you test it?

S: Like for instance I can give you an example. For instance you’re using-- let’s say-- one recent project I was working on, they were using minus 1. Minus 1 for a record, a primary key. They were using minus 1 or 0. Because what is the significance of minus 1 or 0? The record is not there. When the record is not found, I want the behavior of system to be this way. Versus when it does find it, it does something else. So if you just use the magic number like minus 1 and 0 in your code everywhere-

A: [inaudible]

S: it’s all over the place. You would rather have a constant defined as illegal primary key = minus 1. That’s it. You just say illegal primary key. It signifies okay, that’s what the meaning you’re attaching to it. Zero or minus one.

A: What I meant was, if you could show us an example how to use TDD to find such problems. I understand magic numbers. I’ve seen the problem, how do you test it?

S: Yeah, that we have to work on a problem to see. When you start writing one test, two tests, three, and then you-- once you reach the third test, you start recognizing certain duplication. The clean up code-- make it right-- start it right, write a failing test. Make it pass and then you refactor. Refactor is a state when you actually recognize the duplication. You clean up. It’s time for a clean up. The best way to actually do it, that’s why I want to actually give you the exercise and once you start identifying what the duplications are, you are going to be cleaning up those things. You have to actually do it in order to

A: It’s not something you could detect through TDD tests? More like something that you’d find out during refactoring?

S: Yes, you can actually see how it emerges. You want to look for the pattern as it emerges, as you code.  So, let’s work on that factorial. If you guys want to start working on it now, it’s only going to take a half hour. It’s up to you guys. 

[end video 2. First 0:05:05 of video 3 same as last 0:05:05 of video 2.]

S: So, the next section is the basics of testing. This is again divided into subsections. We will see some terminology before we can discuss how to write a test and all that we need to know. Look at some testing-specific terminology. And then we will see some bad tests. Either in the existing codebase-- you will know, okay, these are the bad tests. You will be able to recognize-- this is a bad test. And if you know how to write a good test, and you know, okay, what is it you can aim, how high you can aim. And then the stubs and mocks, which is an hour worth of material. Mocks I think is the most important part of today’s session. 

So the first thing is terminology. To give you an analogy before you even dive into explaining what the terminology is-- it’s just a very simple-- I come from electronics background, so you-- it’s just a breadboard, and you have LED, and you have a resistor-- it’s just a ohms’ law you have a certain specified voltage, you provide the circuit. And you have a specific resistor, and you expect the output is green. The LED is lighting up, so you have input, which is a known input. You get an known output. You have a direct input; you have a direct output. 

That’s what you actually did in your Fibonacci exercise. You give a direct input and you get a direct output. You were able to observe the input that you sent, and you were able to observe what was coming out of the system. This is direct input, direct output. 

So the control point is wherever-- we are providing this input, those are all the control points. Control points can either be observation point-- observation point is where we are observing what’s happening, what’s returning, you know. In this case you can see that LED is obviously visible, so that’s the observation point. So I will tie this thing to the testing terminology-- the few slides from now there will be a diagram. 

So these are direct inputs, direct outputs. Sometimes you have a complex circuit like this. It’s not always a simple ohm’s law kind of a thing. This is what your code is actually going to be. In the real world, it’s going to be really complex. In this, you have a really complex, integrated circuit. It’s not like LED where you can with the visible eye-- you cannot see anything. But it has-- if you have this probe, if you have this thing in your observation point, you can see it has-- it’s creating this sinusoidal wave form. But you can’t see it. You need a special observation thing in order to see it, capture it, and view this particular thing. That’s what’s called indirect output. You need an observation point in order to see the indirect output. 

So for our software equivalent, it would be like sending-- somebody signs up. I need to send the activation email. Somebody registers, I need to send them messaging-- put the message in a messaging queue for instance-- its asynchronous kind of thing. You cannot observe it. It’s not returning your results. It’s indirect output, similar to this. 

So direct input, we already saw. That’s the incoming thing which is incoming message. You are sending message to somebody with a known input. So here is the indirect input and showing you this diagram right here.  You have a-- I’ll be going over this thing in more detail as I cover-- once I go through the terminology I’ll be covering this canonical test structure-- how will this structure, and I’ll explain what it is. For now I just want you to observe. 

In the exercise step I am just sending a message to whatever I’m testing. SUT is a system under test, whatever I am testing. It could be just an object with just a method and an object. See, it has dependency on someone else. Objects always collaborate with other objects in order to accomplish something, some task. But it also requires some indirect input for somebody else because it collaborates with the other guy. Dependent on some other object. So that’s providing certain input and it needs this input in order to do its job. So this is indirect input. This is like drawn like this because it’s invisible to you. That’s why it’s indirect input. It’s not-- you cannot directly do a puts, or you cannot do anything. So direct output, we already saw the result. If I call this stateless thing, the Fibonacci thing, it returns me a result. It gave me an integer. That is a direct output. So indirect output, like one of the thing I mentioned was somebody signs up, I sign up. User sign up, okay, this is a sign up module. It needs to send something to the email, action mailer, this is another component. It’s basically a framework. It needs to send an email, but we cannot see an email that has been sent to somebody else who just signed up. It’s not coming to our inbox. We cannot observe it. That’s why it’s called indirect output. That’s why it’s within this. It’s like a hidden here. It’s invisible. So, it’s indirect output-- how we test something and come back to it later. We will revisit them. 

Just now, get the distinction between direct input, direct output, indirect input, indirect output. There are four different things you need to be aware of. The way it is indirect-- you cannot see the indirect input and indirect output. Whereas the direct input and direct output, you can see them. It’s coming to you as a result of some particular operation. 

So in this case, it’s an object, all the incoming messages. It’s a part of the public API, all of these incoming messages-- someone else is a client for this object. And it depends on a particular-- some other object, dependent on a component, some other package, module, whatever you want to call it. It’s putting some message into a message queue, it’s putting something into the database, inserting a record into the database. When somebody signs up, he needs to-- somebody purchases something, you want to actually put the job in the queue and process it later. Because anything that takes a long time, you want to handle to handle it asynchronously certain cases because you want to immediately return back to the customer. You want your apps to be responsive. So all of these things are indirect output. It’s going to a messaging queue, it’s going to a database, these are the incoming messages for this guy; these are the outgoing messages for this guy.

S:  So, here everything is put together. You have a setup that you initialize SUT. You put the system under a certain state, a known state. And you provide direct inputs through the control points. At the exercise phase, you call. In your case, it’s Fibonacci, you call a number or sequence of something. That’s when you actually invoke the method. That return the value, within the return value, you got some value back. And you verified, verified using an assertion. The results should it equals zero and you check the state.  Through the observation points, you were observing what the direct outputs were from the system which was under test. And you verified. I will go through the four stubs and say which is applicable or not later. For now I just want you to focus on the terminology. So these are all visible. See this invisible thing? So it depends on something else. Somebody else needs to provide-- I have code sample coming. 

I will show you how this indirect output, indirect input actually looks in the code to you. I know it makes it more concrete if you have a code example. Just bear with me and focus on the terminology for now. So indirect output is provided by the dependent-on component, and indirect output we already described. Could be messaging something you’re going on behind the scenes. You cannot really observe. So, just the basic terminology.  Introduction to basic terminology. 

Now we are going to see how to write tests. So, this is divided into four subsections. I will show you the canonical test structure, four phase test, we will see the testing techniques, messages, and some testing guidelines. Like Gabriel said, all these guidelines are just the guidelines to begin with. You can violate them if you can justify them. You can reason them and it makes sense to another developer sitting next to you. And he says, “Okay, sounds good.” Before I even go into those subsections, I want to set the context here first. This guy, who is this guy? Brian Karnigan. Anyone?

A: C [inaudible]

S: Yes, he’s a very smart fellow. He had something really important to say about this…. Remember this. You think you are really smart and you write the cleverest code you can write. By definition you’re not qualified to debug it. And it’s coming from Brian Karnigan. So keep the test very, very simple. The reason we have the test is basically because we want to avoid spending days in debugging. So, we want to keep the tests really simple. We don’t want to be clever. What should I do then? Only focus on what, not how. How is all about implementation. What, what is what focuses on specifying the behavior of the system. You always want to focus on what. Not how. 

How is all about implementation. So when you focus on what, and you don’t do any of those how, your code is going to be declarative. By definition, this is what declarative means. If you look at Rails code, it has the has_and_belongs_to, has_many, those are all declarative. Just specify, specify, specify. Specify the relationship. ER modeling one to many, many to many, you specify. It’s declarative code. So declarative is all about the what. Imperative is the exact opposite. It’s all about the how.  Imperative is a different kind of programming paradigm. We want to be on this side. 

So, we have this keyword specify in the RSpec. I’m going to the dictionary definition of specify. You just throw this term, specify behavior. What does this specify actually mean? To state a requirement clearly and precisely. That’s what it is. We want to specify a behavior. There is no ambiguity. It has to be clear, and it has to be precise. When you’re writing a test, you focus on one thing and one thing at a time. Every test, just focus on doing one little thing at a time. 

Let’s look at the first subsection which is the four phase test. Four phase, we have like one two three four. Four of them. Setup is phase one. Setup is when you actually create some objects. You put the system into a known state by creating objects and all that. It’s also called as test context. The system needs to be in this state before you can actually invoke anything on it. Before you exercise a method, you are doing something to the-- you  are going to invoke something to-

A: Often when we’re testing, we’ll launch specify what I call “happy path,” and also certain pathological cases. Do you recommend-- because often we’ll have certain tests that we’ll setup not in the setup method, the pathological case. Do you recommend separating those into separate test cases?

S: Very good question. I can actually say, to some extent, you want isolation between tests. When you have the alternative scenarios, like the pathological cases, it depends how much of the test context you’re going to customize. I always want to be very clear in my tests. What is the specific that I’m focusing on? If you can have a generic before that handles almost all of the cases, I would override in that specific pathological case whatever I’m overriding this thing, has to-- it has to communicate intent. 

I’m pathological case number one is what I’m testing. I’m making the test very, very specific. If you make it within the same test case, then it’s very clear to anybody reading this thing. “Oh, I see the relationship between the test context and the behavior I’m going to exercise, invoke on.” Okay, clarity. Clarity is-- I would have that clarity, being able to override in your specific things. Regular things, all the different things to customize according to what you’re testing. So your intention is very clear. Does that answer your question?

A: So you’re saying have a context, and then the code let’s say you want to have certain attributes, just assign it to them?

S: Let’s give a concrete example. You have a valid user. First name, last name, email address, everything is valid. Pathological case number one. This guy is entering an email that is invalid. I actually have a  valid user. If I am using a factory girl, I can actually override email to an invalid email alone. And check that your validation catches the invalid email. I override. 

Factory.create email list, I provide invalid email. All the attributes is valid because the factory girl provides the default values, which are the specified in the factories.rb. So, in the case just by looking at and dealing and providing an invalid email, when I’m reading the code, I know exactly, “oh, I’m testing the pathological case.” What happens if it’s not a well-formed email address? That’s what I was trying to get at. You’re customizing the test context according to that specific test you’re actually writing.

A: So do you mean, within the context, write the happy and non-happy-

S: Very good question. The thing he brought up is we have a happy path, golden scenario, that’s applicable to most of the cases. I want to have it in my factories.rb the happy path. Valid object with all valid attributes I will override sometimes-- the last name cannot be blank. I will override only that particular thing. That’s relevant to that particular test. Is it clear?

A: Yes. 

S: So that’s how we customize your test context, depending on what test you’re doing. And then you can exercise. Verification state is where you do results that should equal equal. You have a lot of matchers. I will give a crash course of RSpec matchers. Most of the time you’re going to be encountering these things, and if you need something else, you can always refer the documentation. 

And the teardown, is if you have unit tests, you don’t really have teardown. Each test should be isolated. At the end of the test, you need to revert back to the state before you had the test running. So, in unit tests, most of the time, you will not have this phase, because-- unit test by definition, you should not be hitting your database, you should not be going to a file system, you should not be going to any of the external resources. You should not be going over the network, for instance. It should be self-contained. If you are going over the network, doing all that, it becomes an integration test, it’s not a unit test anymore. In that case you need to teardown the network connection, you need to release the resources, file system resources, anything you’re hanging on, in your teardown part of it. Whatever setup-- establish the network connection, but you need to release them here. Establish the database connection, but you need to release them here. Database, webservice, calls you are setting up, connections, you have to release all those resources here. 

So the next test when it runs, it gets a clean state. And it’s going to actually do a setup for its according -- whatever thing it’s testing, it’s going to setup its own test context. This way, one test context will not affect the other test context. The dependencies between tests will not be there and you can run any of the tests in any order that you want. There is no dependency on the order in which you run the test. 

You want isolation, independent tests. Now I said in unit test you don’t have a teardown. It becomes-- it degenerates to this three A’s-- it’s also called three A’s. First step, setup phase, you Arrange. You arrange, create some objects, do something. You put a system in a certain state. You act on it. This is where the exercise part was in the previous slide. And then you assert. This is the verification. A, A, A. This is called three A’s. 

If you look at the cucumber, same thing. It’s at the macro level. Given when then. Given the system is under this state, given all these assumptions are valid, when I do something to the system. This is when I am acting. Exercising the system. Then something happens to the behavior that I want to verify. This is when I want to assert the behavior. So I can verify. It’s at a macro level. Business intent is revealed here. It’s a customer test. 

This is a variation of the canonical test structure where you have a setup but if you see this before exercise, you have a expect. You’re setting expectations on a certain thing. Mocks, I’ll be covering it later. I just want you to get a variation -- it’s an alternative thing. We don’t see verify at all. Because when you set an expectation, there is an implicit checking at the end of the test. The framework actually does the verification for you because you made the expectation here.

A: When is this?
S: This is when you will be using mocks. This is-

A: Yeah, because I’ve seen like “should receive” and then you call them?
S: Yes, this is “should receive.” That’s setting expectations. Outgoing messages, the terminology is indirect output is what you’re setting here. You’re saying that this is something I cannot see. I cannot see it, I want you to verify it for me. That’s what you’re saying essentially. 

RSpec will verify if the call is made, it passes. If it doesn’t it fails. Already I am throwing the term  SUT but I want to define what this SUT is. Based on the context, SUT can keep on changing. SUT is a system under test. In this case, when I’m writing a unit test, this SUT is just an object, just a message. I’m sending a message to this thing; I’m testing it. I’m writing another unit test. It’s testing a different object, but it has a dependency on another object here. It uses something else. But I’m testing them in isolation. 

But when it comes to the entire thing as one unit, it’s one component, I have a component test, that is going to exercise the entire thing as a component. To answer some of the questions that you had, for instance, you would test these two in isolation, when I write a component test, I don’t really mock any of this thing. I let the real interaction go on because I want to integrate them. This component test is more of a mini integration test for these objects here. It’s more like a -- you think of this as active record this is your custom thing which extends your active record. You have a dependency basically. And when you write rails unit test, it’s going to hit the database; it’s like a mini component test in this case. 

To give a concrete example. So you have a component, a cluster of objects within the component, you’re testing them. Again you have a component test two, another component, you have a cluster of objects instead of that. Like you’re only focused on testing that. Maybe it’s like a pricing module or it’s like an external API call going to an authorized.net  or something with the-- all belongs together. And application level-- the entire thing is a black box. The entire application is a black box. This would be what in our case? For instance, if you’re considering a Ruby project. This entire application is a black box. The entire application is the system under test. This was a system under test; this was a system under test; component became a system under test; cluster of components has become your entire application. This is basically your cucumber. 

This is a black box. What are the events that a user can do? User can purchase, user can put some product in the shopping cart, user can check out-- these are all the user-level events going into the system. And the entire system is actually doing something as a black box, and it’s allowing users to accomplish their business goal. Everybody has their use case, actor -- everybody has their own intention when they’re using the system. So you don’t really care what’s going on inside. You only care about what’s going through this and what’s coming out of this. It’s a black box because you don’t care what the state is inside the system-- of your application. 

So we just saw what does a system under test. Here are some of the beginner’s mistake-- even I have made it. Actually have this system under test which is just object right here in green. But when you have a fake object, if it replays the entire system under test, you are not testing anything anymore. 

You have fake-- you can program the fake. I have a code example for this too I can show you. Right here. Don’t mock yourself out. This illustrates tautology Because here I am creating the stub. The object called Paul and age, method is returning integer. And then I’m just asserting Paul, age should equal 18, and this will always pass, because that’s what the stub is programmed to do. Your replays-- if you’re going to test a person object, and if you can respond with the age, where is the person object? You replace the entire person object with a stub, so whatever you’re doing here, it’s meaningless actually. 

So this is one of the beginners’ typical mistakes. And right now I’m showing you very, very explicit example, but in your test, if you’re using partial mocks, if you have a read RSpec book, you can use partial mocks, and some of the things are very subtle and you might have a little bit of overlap, and because of that overlap, you’re not really testing anything. Your stubbing or mocking is doing your stuff and you think, okay I have a false sense of confidence. You have to be very careful when you’re using partial mocks. And use them very sparingly if you do use them. 

Here is another beginner’s mistake. We have SUT 1 and SUT 2. I showed you the diagram where they were all independent of each other. Now, in reality you have some overlap. SUT 1 and SUT 2 has some overlap here, which means you have tests for object 1, tests for object 2, you have some assertions that is common across both tests. Which means you have duplication basically. You specify once and once only. You don’t specify multiple times and multiple tests the same thing. You test the one thing and one thing once only. That’s it. There should be no overlapping tests. 

You’re basically adding an unnecessary burden of maintaining a test in order to-- just to get a false sense of confidence. No. And this may not be obvious because it’s across two different modules. It’s in two different objects, two different packages, so finding this overlap is not that easy actually. And different developers are working, this could happen-- it happens unintentionally sometimes. 

So we already saw the canonical test structure, the four steps on it, setup, exercise, verify, teardown, and we saw the degenerate, where we had only three A’s. Three A’s are what? Arrange, act, assert. We don’t have teardown because unit tests, we should not be hitting any external resources. And then we saw the variation of it when you’re using a mock, you have a setup, you have expect, and then you have exercise. There is no verify as such. It’s implicit, verify. Rspec does it implicitly. And we saw the four different things, and then what are the beginner’s mistakes that you could make? What is a system under test, what happens when you have overlapping tests, what happens when you replace the entire SUT with a stub. You’re not testing anything anymore. 

Now we are ready to look into testing, some testing techniques. This is what you actually did in the example -- the Fibonacci thing you wrote. You hardcoded everything. You were just faking it. It was not a real implementation. You knew it’s not going to work for all cases. But you still did it. Why? “Fake it till you make it” allows you to actually take that one little step. You had problems with class not found, all the syntax errors, everything you got past that stage, then you wrote another second test that was also hardcoded, third test also hardcoded, and then you eventually had to replace all the constants with variables. With abstract solutions. 

Because you know that’s the only thing which can handle any arbitrary number and it can give you a valid answer. Not the hardcode ones. You can extend that solution to any number-- of arguments. “Fake it till you make it” is used when your domain is unfamiliar. You don’t know how to approach the problem, but you want to take baby steps, small steps one at a time. And you gradually converge towards a abstract solution. It gives you-- initially it gives you that momentum. You start generating momentum. You learn more about the domain, you get more comfortable, you learn more about the system. It’s a learning process. As you learn more, you start to write progressively more difficult tests. 

And triangulate. This is a mathematical term. You measure the ship from one point, from there you measure what the angle is, and then again you go to another place and you measure the angle again. And then you plug it into a formula and you find out what is the distance of this ship from a given particular point. It comes from mathematical term. 

When applied to TDD, I gave you examples, like I gave you a table. Zero is zero, one is one, two is one, three is zero plus one or two, it kept on, I gave you that example. Each example, if you’re using triangulate to solve the problem, you take the first row and you have executable example, second one, executable example. Third one, executable example. 

You gradually make the test drive the abstraction out of the code. You handle the boundary conditions, boundary conditions, okay I got past some of the things I was having problems and now I’m more comfortable handling the abstract thing and eventually you solve the actual problem. You triangulate.

 You’re coming from all this-- you’re kind of going from different points, you’re measuring different angles. You’re having different boundary conditions, and eventually you’re going from all the different and the problem domain, eventually you have enough confidence in solving the actual problem. 

The right solution-- if you’re so familiar with factorial or Fibonacci, you could just type in the obvious implementation. That’s the right solution. Obvious thing is, okay I already know this. I’m familiar with it. You just type it in. That’s the right solution. Nobody says you always have to fake it till you make it. TDD allows you to take small steps. That doesn’t mean you have to always take baby steps. If you are confident, if you’re familiar with the problem domain, you can go, you can take a much bigger, longer step if you need to. As long as you get to the green quickly. That’s our goal. 

Those three techniques were at the smaller writing the test level. Now this is from the entire system level. Working-- considering the four phase, if you’re considering the four phase-- we saw the four phase setup, exercise, verify, and you had teardown, right? Three things. Working backward is exactly you’re not going from one two three, you’re going from three two one. 

For instance, I’m writing a calculator for instance, five plus five is ten, okay I know it’s going to be ten. Manually that’s what I’m checking, but how can I automate that manual checking process? That’s what is called an assertion. Five plus five is ten, so you write that assertion. That’s-- the statement has to be true. That is the post condition state of the system that has to be true in order for my test to pass. You start with the assertion, okay that needs to be true, and then you work your way backward. Sometimes it is easier to go backward. Write the assertion first, then you exercise the system, and then you provide this context it requires so that I know, okay, you can exercise the actual object under test. 

This is outside-in BDD, inside-out the classic TDD. Outside-in, what does outside-in look like? Why is it called outside-in? You start from the outside, you always start from the user’s perspective. You write a cucumber test or something. How does the user interact with your system? They actually click on “add to cart,” right? But events are coming in externally. And how is your system going to respond to those events? It’s coming in, you have a system under test, you have SUT, that’s actually how interaction with another SUT and so on. This is the one that is independent of everybody else. And each of these layers, you’re using lot of fake objects.  Test doubles, stand-ins. For these guys, actual things. And either to make the test run faster, if it’s unit tests, you actually make the test double. If it’s a customer-level test, you use the actual object. So it will make your test run faster if it’s a unit testing thing. So SUT actually uses the test double. In production it’s going to use the real object, and in the customer integration level test, it’s going to use the real object. All the tests are coming from outside-in, the event’s coming in, and it gradually goes to the entire layer. Each layer in the stack of your system. So outside-in, you start from here, number one. Write a failing acceptance test. 

Number two, does the acceptance test pass? If it passes, the feature already exists. You’re done; you don’t have to do anything. If it fails, you drop down to the unit testing level. You write a failing unit test. And then you make the test pass. And then you refactor. This thing we already discussed in detail in the previous session. The only thing you’ll notice is the outer section. The outer circle. Outside-in, we’re coming outside-in. We’re starting from the events coming in from the user’s perspective. That’s going to drive the entire thing. And if you keep on doing this inner circle, many of these circles, eventually it’s going to make the outermost thing pass. That’s how we know you are done. Because that’s the acceptance criteria

A: So here, acceptance, do you mean like a cucumber test?

S:  Yes, cucumber test, acceptance is the cucumber test. Higher level. This is the outside-in, the BDD, when you say “I do BDD,” this is the outside-in development. Because-- one other thing to remember, when you’re running the cucumber, you exactly know what to do next, because we are giving you the steps, these are the pending example. This is what you do next to get your test working, given when then okay, go ahead and do this. And then eventually drop into the inner circle and you do a unit test. So-

A: What is BDD versus TDD?

S: TDD, remember I discussed about the classic TDD? TDD began just as TDD, like Kent Beck what he does when he’s coding, he always uses real objects. If you see him coding, there’s a programmers’s screen cast  by Kent Beck, he even uses actual server when he’s interacting. Actual server is running on his machine when he’s coding. He does not use stubs, he does not use any mocks, nothing. Uses real objects. He uses inside-out development, not outside-in. It’s inside-out.  

Starts with the domain model, slowly the entire model, one of your business objects is depending on some other business object, eventually he goes and depends on some business object; it’s not depending on everybody. 

Eventually he goes to the next layer, other business layer, you have some interfacing layer. If you have a messaging system, you have a messaging adaptor, or an ORM adaptor if you have an ORM going to a relational database, you’re going to a web service. He goes rows, and he goes across layers and eventually the entire system is covered.  It’s inside-out. Why we start with the code. So that’s what inside-out is all about. This is the TDD. TDD, BDD, this is the TDD. Classic TDD. This is what they do. Outside-in, that’s the BDD guys what they talk about when they say BDD, that’s what they mean. 

In TDD, you start with the test, the SUT. You start with the test, see you don’t see test-double anything here. You don’t see anything. It’s all real objects. This guy is independent of everybody else. Obviously you start with this testing independent object by itself, now I have this guy ready. I can test this guy when he’s depending on him, and I’ll just let him use the real object. And so on. I gradually do the entire cluster of objects, once I test, I’m gradually going to go to the next layer, next layer, until the almost boundary level objects, which is going to be interacting with the UI, messaging queue, anything on our webservice and then it’s going to hit external systems. It’s going to cross layers. 

So we saw the testing techniques in the sense, what are the things, triangulate, “fake it till you make it,” obvious implementation, it’s like a very, very minute level like typing in your code. And you have several options of which one to pick, based on how confident you feel about the problem domain, and how confident you are familiar with the solution, what is the alternative solution, am I comfortable with this, whether it’s going to work or not. And then we saw from an architecture system level view of, okay, what’s this outside-in? What is inside-out?

 Two different development methodologies that also allows you to focus, when you’re using acceptance criteria to drive the entire thing. Testing the entire system, versus doing inside-out, the classic TDD, guys like Kent Beck use. 

The next section is going to be on messages. Everything actually can be boiled down to just messages being sent from one object to the next. And either it’s incoming messages to an object, it’s an outgoing message to an object, it’s a message sent to itself. So what does a message that an object that is sent to itself? What does it mean?  Sending a message to itself. 

I’ll come back to that thing again. Right now, I just want to focus on these two objects right here. We have all of these variables taped of an object encapsulated. 

[End hour 3.  Video 3 @ 0:45:37]

