[Continue video 3 ("TDD bootcamp part 2") at 1:45:10]
S: Explanation test. This is actually-- everybody is in a situation where I want people to adopt TDD, and even though other developers don’t have that discipline to write the test first, another developer comes to me and starts talking to me about how the system should behave, I give the explanation in terms of tests. “Oh, given this setup, if I do this exercise, what I expect to happen.” Given then when I actually explain them in terms of tests. “Is this what you mean? Yeah, yeah, yeah, and then I write a test. Explanation test. You may say something to me, Well, I’m talking to you, but when I go and actually get the test to work, that assumption may not be true. Only the test can tell me whether you are right or wrong or maybe you just forgot to mention one minor detail because it’s kind of like vague. There can be no vagueness in tests. There’s only pass or fail, no maybe. It has to be clear and precise. And the test cannot lie. Sometimes there is false positive, false negative, that means it’s lying. 
So another test. So this is something like for instance, you’re writing a controller-- some logic is getting messy and-- should be [only fat SS] model. You know what? We should actually move this thing to the model layer. Let’s write another test at the model level and then we’ll come back to the controller. Write another test. Don’t get distracted--  put a pending in your controller, pending this, you move the logic into your model test, make that one pass, and then come back to your controller. You can move the pending and then get this thing working using the new API that’s in your fat model. Sometimes it’s not related. Something is distracting you which is non-related, you just put it in your to-do bucket. You’re having a paid programming session, and suddenly you say what happens if this, this, and all that, and you’re just trying to divert my attention. If it’s not related, I put it into my queue. “Oh, that’s a very good point you brought in. I think it will have business value. Let’s put it into our to-do list. It should do something blah blah blah, pending. We’ll come back to it later.” So you go back and focus on what you’re working on right now. It’s another test. Later, pending. 
So the regression test. When a bug comes in, you actually, ideally are supposed to write a test that’s going to expose the bug. Okay, the bug exists, and you fix it, so the failing test now passes, so now you know your bug has been fixed. It hasn’t broken anything. And then the question that you ask-- that’s the regression test you wrote to fix the bug. And then the question that you ask yourself is, Where else in our system can a similar thing have happened? Where else can a similar thing have happened? You’re basically trying to see my safety net, the holes in my safety net; I want to make it smaller. So I don’t get more regression bugs going through. Regression test just means you’re not-- system is telling you you’re not done designing me yet. You haven’t sufficiently had enough coverage to be confident, Okay, this is going to work and provide an opposite value.
A: What is the explanation test?
S: Explanation test is basically you’re in an organization where TDD is not really the thing, and you’re asking something-- they’re asking something about the system or you’re asking for clarification from them. But the way you communicate is using the structure I showed you, the four step. Even, and then, or setup, exercise, verify. Oh, is it how this thing is supposed to work? You capture that so that you can write a test for that. You get to the-- developer conversation, you get to that structure, so it’s kind of like you’re learning more about that system, maybe you’re new to the company, and this thing gives you a framework to talk in a very structured way and also make sure whatever the information they’re providing you is the right information. 
Use TDD to write test utility, like you said, the way you’re checking what you’re doing, I can just have an assertion for custom range check or something; I could name it domain-specific way, but you need to have a test to test that so that it can work across different data sets, catching the boundary conditions, and all that. So use TDD to write test utility so others can use it. Because I want confidence; I want to make sure there is no bug in the test, or the library that I’m going to use across all of my tests. 
So, this just kind of shows at the setup level, you can have a creation method, it’s like a factory method. If you’re using factory girl, that is basically the creation method right there. You don’t have to write your own utility. And then finder method, you won’t really have much finder method. Exercise phase, encapsulation method, this is when you’re actually exercising the behavior, sending something. Verification stage, you have verification. These are all like customization in the verification stage. Cleanup method, if you want to clean up resources, if it’s very specific to paypal thing, you want to have a cleanup method that you can reuse across all your integration tests for instance. So each of these things raises the level of abstraction. Depending on what step it is, it’s just named differently. Test utility methods. And you have tests to actually test these methods, your domain-specific different tests that you’re going to reuse across different modules, classes, that you might retest. 
So don’t have any loops, keep the tests simple, no if statements. If, but, all, else, no switch. No each, for each, all those things. Why do we say you don’t really need to have loops, conditionals, all that? More conditionals you have, more code paths you’re going to be having in the tests. And more difficult it becomes to reason how your test is actually going to behave run-time. You don’t want that. You want it to be able to just by looking at the source code, immediately you need to be able to say, Oh, okay, I can exactly say what this code is going to do, it’s so simple. 
Avoid conditional test logic, we saw all that. Expected behavior specification, you can actually-- if you have two objects like we kind of discussed this thing, you can pass those two objects because we already know we want to aim for just one condition, verification of just one condition-- what if we need to have a customer-- I want to assert, Okay, the customer was charged. Amount paid was this thing, this was the amount, all those things. If they want to have multiple assertions, I don’t want to do all that. I want to just say, here are the customer object, do whatever assertions you want. It’s like the internal library utility will do all that for you. There’s the expected behavior, specification, you can write your own stuff. It just takes the object and it asserts on different things that you really care about. These built-in assertions-- RSpec has a lot of built-in matches, Delta assertions, and bully and thing and all that. I will give you a very quick tour of all the RSpec-related built-in assertions, more like a crash course. We’ll breeze through them toward the end of it.
A: Yeah, actually I want to do sometimes if you have to create-- I have seen some people using as [in objects and third as null objects SS].
S: Oh, yeah. Remind me [as null SS] object when I freeze that thing; I’ll tell you when you use it and why you use it. Domain assertion really specific. Your business logic is a domain-specific assertion.  It raises again, becomes more expressive. Sometimes you start to have puts here, puts there, and you want to see what’s going on, what the expected value, what’s happening, instead of using puts, just write your own diagnostic assertion that’s going to say, okay, this was expected and this is what I got. It’s very very self-explanatory. When you run this assertion, you will still have a puts, but it’s basically assertion and it’s more-- it gives you more diagnostic information. Instead of having puts everywhere, you-
A: Don’t put puts-- to assertion-
S: Exactly. Put diagnostic assertion so it provides you-- if you need more information-- see, if you’re using a debugger, the main reason for all this TDD is don’t spend like three or four days trying to hunt that one elusive bug. You don’t want to spend your time in the debugger. But putting puts is kind of like substitute for not being able to inspect variables or looking at that particular attribute, value, stuff like that. Instead of doing that, create a diagnostic assertion, and use that diagnostic assertion which will show you what are all the values of that particular object are [interested in SS]. You can have a custom tools method for that custom object, and you can say, the customer first name and last name has this, this, this, something to [it SS] which will make sense when it is output to the standard out. So you will know, oh, okay, this customer was charged twice or just by looking at the output, you can get a lot of clarity on what’s going on. 
A: So basically I was debugging nasty code with a lot of logical branches, like if conditions, and the code-- [the input SS]-- is not taking the path I expect it to go, so I had to put a lot of puts throughout-
S: Here’s the thing. Especially if it’s a code that you have not written, somebody else has already written the code, the only way you can learn about the code is by putting the put as statement in there and running the browser, checking to see, okay, this is-
A: No, this is my code. It turns out because the input object wasn’t the right class. So you’re saying instead of using puts I could just write assertion statement in my TDD test case to tell me what’s the result of this evaluation. 
S: You can write an assertion, custom utility for your object, that can take that particular object, or you can write even a general one, as long as your object can respond to yes and dumps all the attributes for that particular object.
A: Essentially writing was in my if statement and then sort of assert whether it’s true or false, like turns out to be true, or turns out as false.
S: Yeah, you can have a guard assertion instead of if statement. 
A: How do we do that?
A: Let’s say in her case, she wants to check the test. The object is not right. So you’re saying-
A: [I explained it SS] was in hash, but it turned out I was in string.
S: Yeah, that’s a good one.
A: So if object is an instance like this, can we check like that?
S: No. Basically when you start checking toward [instances SS], those kind of thing, you’re going to lose the benefit of polymorphism. As long as certain thing responds to certain message, I don’t really care if it’s a had, or [1:58:14] because they are responding each [for instance SS] and they use the values. And he’s-- for your case, your assumption was something, was supposed to be hash and turns out to be a string. Basically you’re still debugging. What I would suggest-
A: But you’re saying diagnostic assertion for debugging.
S: Diagnostic assertion can be used for debugging in cases where you want to dump the particular object and you don’t want to inspect the variables-- what are the values in the variables?  I want to see. Why do you do [unit SS] test? You want to see.
A: Instead of doing puts-- he’s saying just how we put [bloggers SS], he’s saying just do in spite and that way get to what the object does. He’s saying customize the tools method and tools method will print all the way-
S: Print in a very legible way.
A: You’re saying [1:59:15] instead of a code.
S: Yes.
A: Not using diagnostic assertion or TDD.
S: No, this is in some cases you need to inspect-- do the diagnostic assertion. In your specific code example you gave me, there is a lot of if statements and going all those things, you are testing too many things at once. Usually, if you’re writing a test, I showed you like four steps. In the four steps, in unit tests, they came up with just three A’s, three steps. So if your test is going beyond three, four, five lines, if you follow one of the test guidelines, it says verify only one condition. Only have one assertion. You only have few objects you need. The minimal object-- you always create minimal objects you need to test your system. Context should be minimal, because you don’t want to create too many objects which is unnecessary for whatever you’re testing, because you want to reduce the test context so your test will be faster. If you do that, your test will be four, five lines at most. If you have a longer test, you’re testing too many things at once. SUT can be too large. That’s one of the beginner’s mistakes again. If your SUT if too large, you’re testing too many things at once, it’s called as an eager test. It’s like a poetry that just keeps going on and on verifying this, that, and every other kitchen sink under the sun.
A: Let’s say I have a suite or four levels of nesting if statements. Can I just break each level into a single test case?
S: Here is a question for you. Can you write tests without writing an if statement? Can you challenge yourself without using an if statement? I have a constraint for you.
A: No, that’s not my code has if statements-
S: You have nested four if statements, right? Whenever you are using if statements, most likely you’re not utilizing the polymorphism to the full effect. You’re depending on something. Like she said, instance of, you’re checking instance of. What is the conditional that you need to have so much of in our [nest area SS] first of all? Maybe the object is not following the single responsibility principle, for instance. It should do one thing and one thing only.
A: Actually, in this case, it’s not really object. It could be a user input text where the type of message-- based on the type of message, I look at the status. Is it fail or is it successful? I take different kind of actions. It’s not really-
A: I think there might be a way to refactor the code to reduce the level of if statements, but there are different techniques for that. 
S: Yes. The command, like command [pattern SS] for instance.
A: If I’m hearing you correctly, you would probably recommend having one test method for each of those different-
S: Yes, I would. Break everything inside of those-- I would break it and separate it on its own.
A: Right, so each level is its separate-- that’s what I was asking. 
S: Yes. Exactly. The one thing I was kind of confused was you were mapping whatever the user is [specifying SS] to some other command or something. Mapping of that-- also you can use polymorphism for that. 
A: In this case it’s not a real object because then I’m getting user’s SMS message, and it has a specific format. So it depends on the message; the message has a few fields. It depends on the value of each field I need to process it differently. Because it’s not really an object-
S: It’s more like a mapping of events to a handler, human handling.
A: Right.
A: You might be able to abstract it to a factor that gives you the handler, and then all the ifs are factored into the behavior separate, but that’s kind of more OO stuff-- I’m just imagining-
A: Are you talking about TDD or are you talking about something else?
A: No, this is something else.
S: TDD and design-- you cannot talk one without the other. If he’s talking about design, yes, he’s on the right path. I totally agree with you. Your code is too procedural. When you’re using TDD, the first goal is to drive the design of the code. This is what I was saying:  Listen to the test. If your test has to be like this, there is a pain there. If it’s going procedural I am saying no if, no loop, you cannot impose a lot of constraints here. Why?  I want to make the test very simple and the pain is here. But it’s giving you an indication that the design needs to be improved. The human handler mechanism, the way you handle it, you map to the behavior, [publish it SS], somebody subscribes to the [event SS] and they add handling to it their own way. Behavior changes based on the environment. It all sounds like polymorphism to me, more polymorphic, dynamic kind of messaging. You have to isolate those behavior, encapsulate behavior in an interface. Because you cannot just move that kind of procedural code in the test. It’s giving you feedback that-- you didn’t think about the design. Think more about the design. I would actually read the Erik Gamma’s Design Patterns book and some of the things that they talk about, you can actually find the context and the scenario and see if your problem actually fits one of the things that they’re talking about. And you can follow how they go about-- yeah, Design Patterns.
A: This code is very low-level code.
S: Oh, you’re talking about low-level code.
A: Very low-level that processes SMS messages that I’m getting-- I need to do some basic processing.
S: Basic processing, I don’t know, maybe it’s too low-level-
A: Therefore it has a few nested if statements because I need to-
S: Few nested, yeah, it’s okay. To me, initially it looked like you were getting different events and you were handling it in a different way, the behavior changes. 
A: But if I’m understanding, you would recommend having different tests for different paths. Your tests are having different code paths in them.
S: Yes, that is totally true, because I really want to nail this point-- because the reason you don’t want to have different code paths in the test is, whenever I run a test, it has to be repeatable. I need to very meticulously say, this is the path the code took, I run it 100 times, I need to say, this is going to go through this path, and it goes through this path. If it’s going to go through different path, you need a different test.
A: I understand about the test part.
S: That’s fine, if it’s too low-level, maybe the messaging isn’t going to be applicable to that thing. 
So the verification method you see we isolate, we encapsulate all of the verification, logic, specific to our own thing, our own utility, that’s the verification method. Custom assertion tests:  if you write your own assertion, make sure you have a test for that, unless you have a test, you cannot be confident you can reuse across all your other tests. 
So, do over. Sometimes what happens? Sometimes things are going right; sometimes everybody gets stuck. We all get stuck. Nothing is working today. But no matter what you’re trying it’s not working, so what do you do? Throw away the code and start over. That’s what do over is. Start fresh. Take a 5, 10 minute break, and then start fresh. Maybe change your [pairing SS] partner. Get a fresh pair of eyes to look through it in a different way and see if you can make progress.  It’s not like every time it’s going smooth, it’s like some days are very frustrating. It happens. And also, when you’re stuck, what do you do? When you’re just programming by yourself, you’re just stuck. You just cannot work through this and make any progress. What do you do? Break. That’s what the break is. So let’s see how much more we have. 
So here is a question for you guys. How big should my steps be? How do I know how big my steps should be? 
A: Don’t spend too much time in the red area.
S: As long as you’re green, you can keep on taking longer steps. If you’re getting to green, and you’re getting quick feedbacks, you don’t have to keep taking small steps. You can take bigger steps. And if you’re red, it means don’t take too long of steps, start taking smaller steps. 
So what don’t you have to test? Otherwise, how many tests should I have? Should I have like Fibonacci-- should I say I should have five tests, six tests, or fifty tests, sixty tests? How many tests is sufficient? 
A: 100% coverage.
S: Oh, 100% is coverage? Are you happy? I have like four tests and it gives 100% coverage, is it-
A: 80, 20, 30%.
S: Some numbers. Doesn’t make any sense, right? So, the thing is not about how many tests you write or what is your test coverage. You’re 100% test coverage, it’s good to aim for, the thing is how much confidence do you have in your code. It’s about confidence. It’s about facing the fear in-- how comfortable are you about making changes to the existing code to fulfill-- satisfy the new requirements, changes. It’s not about validation. It’s all about specification. Driving the design of your code so there is no one specific number that you can calculate and say this is the number of tests you have written; now we can stop. 
So how much feedback do you need? I always want quick feedback. I don’t want to spend too much time in red. Being green, green, green, I want to have that loop. I want to minimize that loop. I want to get a lot of feedback. Feedback is what allows me to learn-- to experiment. To write different alternative solutions. It also gives me confidence if it’s all green, it gives me more confidence. I can try much bigger things. 
And then-- I saw you delete the test.  Why did you delete the test? When would you delete the test? When is it okay to delete a test? 
A: When another cover’s slipped completely or-
S: Yeah.[Inaudible 2:11:21] yes. Sometimes you write a test, it doesn’t really test that much, it just kind of gets you in the right direction. And you learn something, and then you have another test, kind of like you said: it covers the previous one. So the previous test does not have any purpose except for allowing you to learn more about the system. Oh, it’s more and more progress for the test. You just delete it. That’s okay, I’m working in a different team and Toefl is working on a team. We have been pair programming and we have been rotating. We ended up writing tests which are very similar. We’re testing the same thing, but we wrote the test in a different way. So, do I want to delete my test, or delete your test? Which test should I delete? Testing the same thing, but it’s written in a different way. The duck string is different, the way we have set up and structured is different. How would I delete this? Since it’s kind of like a duplication, right? Which one should I delete?
A: The lesser one, but-
S: If it is a [zero SS] event, if it is like total duplication, if it’s a zero event, it doesn’t matter which test should be preserved. You can delete either one of them. If it’s different enough and it has communication value-- the way he’s emphasizing, the way he’s duck string is, provides value for his context, for his object, and it provides value for mine, I would just retain them both anyway. Because, go back to the goal we had previously. Communication. Communication is one of the values that the test provides. Not just-- this overrides the thing I said before where you should minimize the test overlap. You cannot be repeating the same over and over again. But if this provides communication value to the team members, yes I would retain it. So you need to know what the goals are. You have so many different things that you need to balance and you make a choice. You have to make a judgment based on what the circumstances are for that. 
So, we’ll see what this round trip test is. Round-trip test basically is a test where you use the public API. I’ve been saying use the front door first. This is the front door. Front door is nothing but the public API. In this case, use a real component test, test method one and test method two, are exercising the SUT. SUT is a public API. That’s why I am able to directly call it. And there is a dependent-on component. It collaborates with some other thing-- okay, this is the shopping cart, to be concrete, tax calculator, I want the calculator and then I need to calculate the total charges that needs to be charged to the customer’s credit card. And then I’m retaining that value. That is a round-trip test. It goes one round-trip. [It goes SS] input, it returns some value to it. And it uses the public API in round-trip test. That’s a real component test. The fake component test-- you create a fake object. Fake object can be a stub or a mock. We’ll see what the differences are pretty soon. We create this, and we install this fake object in the SUT. Which means in the test environment, it’s going to use the fake objects. This is grayed out. Depending-on component is not using the test environment. It will be used only in the production environment. This thing will be. But the fake object is the one which is going to be used. So this is a fake component test. It makes the entire thing run faster. So this is-- calculation of tax calculator, this is a fake tax calculator. It just takes some arbitrary number and just says, okay, 6%. Charge this guy 6% sales tax. That’s what is says. It’s so quick. It doesn’t go to the database, it doesn’t look up anywhere, it doesn’t look up the web service-- internal web service, anything. It’s really fast.
[Stop video 3 ("TDD bootcamp part 2") at 2:15:36]
