S: Because my background is, I come from the UML when this TDD thing movement came out, you had this one [unit SS] thing going on, I was in that branch actually. 

Bubbles don’t crash. You draw all those pictures using all the modeling tools, but you need to start writing code. You do a lot of off-print, these aren’t in the case.  The good news is, TDD is basically a design activity.  And everything you learn, the basics of object oriented design, is still applicable. Whether you are doing the TDD. 

S: There are three learning levels. The first level is you know, you just copy the actions of someone else blindly, using simple rules, and you don’t really know there are benefits to doing it. And the second level is you understand why you are doing the things you're doing, why they make sense.  And the third level is when you start to improvise.  

All this TDD/BDD argument, the goal of TDD is specification not validation.  It's not the verification. Kent Beck says.  It’s just correctness of the code is a side effect. So you specify the behavior of the system. And one of the small problems involving a triangle, Kent Beck wrote like 8 or 10 tests. With Robert Binder, a guy who does testing, he wrote 65 tests. So he just stopped after writing like 8 tests. Why? Because writing a test is a way to drive the design of your code. And it just happens that correctness of code is a side effect. 

Next to the four fluency levels in TDD, actually you might recognize, okay as you go through different phases, which fluency level you are, based on what your focus is. The first level is you’re the Tarzan at TDD where your focus in only on the code. You can write unit tests but the problem is the unit test will only work on your machine, when you put it into some other machine things might break because you have dependencies.  

Second level is where you are focused on code coverage. You can do red-green re-factor cycle, all that, right after, you know your code can work consistently on the continuous integration server, it doesn’t have any dependencies.  

And the third level is your focus has changed from code coverage. Code coverage, at the second level-- there are a lot of people who are so totally obsessed with code coverage.  100% code coverage doesn’t mean anything, especially if it’s C zero coverage.  

S: So my manager was so focused on the code coverage, if it goes belo 80% he wants to even fail the build basically. It’s line-based coverage; it doesn’t say much about the quality of your code-- either the production code or the quality of your test code.  

And that’s where the third level-- you are focused on maintainability. How good is your production code.  We have several different metrics.  You can use metric_fu or something. It gives you all different metrics like cyclomatic code complexity on the different things. Now how well can you maintain this thing?  How well can you extend this system?

S: The fourth level is your focus is now on the design. You didn’t know the main purpose of TDD is basically the design of the system.  It’s not the maintainability, it’s not the code coverage. Design is the primary motive. 

 When you do the TDD you basically end up with a minimal system, right? This is very similar to what I said before. Everything boils down to to zeros and ones.  The progression of a programmer - the newbie realizes the difference between code and data is trivial.  Expert realizes all code is data.  True master realizes that data is code. Right?  

So when I read through Kent Beck’s book on this TDD, a lot of things he does-- it’s very intuitive to him, but people with different levels of TDD experience will find it difficult actually to come up with that kind of intuition.  Because everybody can recognize code duplication in our applications, right? But when I saw Kent Beck coding, I realized he actually looks at the data duplication and he actually applies very advanced design principles to abstract things out from the code. So he’s able to use TDD to drive the design of the code.  But it’s very difficult unless you consciously know what principles you are applying and you apply them to your code.  It’s very difficult to do the TDD to drive the design.   That’s where some of the difficulty arises. 

I’ve been going around everyone asking how comfortable are you with TDD and what are your thoughts?  What makes it difficult?  This is one of the things that makes it difficult.  And I also say that the main goal-- once you know what the main goal is, it’s specification.  Forget about the validation.  It’s not the validation.  It’s not like-- okay, how many tests do I really need to have?  Should I have 100% code coverage?  Do I need to have all different combinations of inputs and outputs and test it exhaustively?  When do I stop, basically?  How many tests should I really write for this?  The answer to that is, you write tests until the fear becomes boredom. 

A: The fear becomes boredom?

S: Fear becomes boredom, basically.  You’re afraid of your code but your confidence in your code, as it becomes higher-- if your confidence is low than you need more tests.  How likely is something supposed to happen?  It’s kind of like a safety net. If the holes in the safety net is bigger, obviously things are going to slip through.  

S: And let’s look at this-- this is the basic structure of any test.  It’s called the three A’s.  The first A is the Arrange.  You create some objects.  That’s the first step.  Second is you Act on them, you stimulate them, you send a message, do something to the system.  And the third step is you do an Assert, you check the results. When you’re writing a test, one of the difficult things is-- some people have found-- What do I check for?  How do I test this thing? Let’s say you don’t write any tests.  How are you doing the programming? You’re looking at the output. And you are manually verifying something. I got the result of adding 5 and 5 as 10.  You are manually checking the output, right?  The Assertion, the third step automates that particular step. So it becomes an automated way of verifying the behavior of the system. 

S: I will go through this thing again at the Canonical Test Structure and go through each phase how it relates to the entire process. So the TDD cycle is: You have a failing test. You start off with a failing test, you make the test pass, and then you re-factor. If you see that it’s red, right?  If something goes red, I mean it’s failing for the right reason. Why should you actually have a failing test?

A: If it fails up front, then-- when your code changes, then you know that it changed for the right reason.

S: Uh, yes. So if you want to say it in another way, the test does not have another test to prove its correctness.

A: Right.

S: So the only way I can know the test is actually testing the thing that I am assuming it is testing, it’s failing for the right reason.  And if it fails for the right reason, then I know, ok-- if I give you a problem let’s say adding two numbers and I write a test which says 5 + 5 =11, that’s a failing test. Is that a good failing test? It’s not failing for the right reason. It actually violates the semantics of what you’re testing, right?

A: Okay.

S: If the 5+5 fails because the interface doesn’t exist, then it’s failing for the right reason. So you write a failing test, you are green, and then your goal should be to go to green very quickly. Usually the 1 to 5 minutes-- within 1 to 5 minutes you need to get to green very quickly. In this first step of the phase, you’re allowed to commit any kind of sins. Very nasty code, duplicated, you can do anything you want to get to green very quickly. That’s the phase one. Going from  writing the failing test to make the test pass-- this one you commit a sin. Your only focus is to optimize the time between this one-- minimize the time between this thing.  And then, in this phase, your focus is only on getting something working immediately. Your focus is only on this particular aspect: solving the problem. Okay, this works. I know this works.  That problem is solved here. 

And this stage here is where you solve the problem of clean code. Clean code of your production code as well as the test code.  You see these two colors?  They’re green. You start out green and when you end the re-factor, you end up green. Okay? If something changes the color then you’ve done something wrong. And then you write a new failing test and this kind of cycle keeps going on. 

S: And Mark mentioned something about the diagnostics. So that also has been added.  When you write a test, there is one more step you can add in here. Make the diagnostics clear. Just for yourself or other developers who will be maintaining your code.  So this is when you make the expected-- okay, this is expected output, this is actual output, and this is where it failed. You exactly know where to look for and how to fix things. Otherwise there is no point in writing the test. Failing tests should actually localize the defect and you should be able to immediately fix the problem. That’s the value in having a test, right?

 So let’s just see how-- I showed you the looping cycle. This is basically a traffic light. And all the valid transitions is how you need to actually code and be aware when you make the transitions. You will see what the blinking lights are and what the all the other transitions are and how it actually relates when you code. 

So for those who have never seen a traffic light: this shows you green-- you go from green to yellow to red back to green again. Yellow, red. So this sequence is a valid sequence. When you’re doing programming you start off-- when you don’t have anything you’re green, you add write something, it goes yellow. Yellow means you may have made a syntax error. It’s a compilation error.  You didn’t do any require for spec_helper or you didn’t have the configuration like one of the problems you said you were having was configuring things. You are in the yellow state basically. Once you fix those things, and it goes red, that’s when it’s failing for the right reasons, the test is actually testing something.  You assume, okay, this is testing this particular thing.  

From red it goes to green. So this is the transition we just saw.  This is the traffic light sequence, how it goes.  These are all the traffic transitions.  These are all the 3 possibilities.  Going from green to yellow, you made a syntax error you corrected, you fail for the right reason, and you make the test pass, you write the production code, just a minimum amount of code to get to green quickly.  So, this is fine, this is fine, these are all legal transitions.  

Now let’s look at the blinking scenario. Where you’re green and you’re green in something with the production code, you’re green, you wrote an another test, it’s still green, it’s blinking green.  Can you think what’s going on here and what we should do? 

A: I would think you’d need to write a new test because you’re not-- your perceived problem isn’t supported by the test data that you’re injecting into the situation. So we believe that this environment that we’re going to set up is a problem. If it stays green and passes the test, then what I’ve assumed is the problem isn’t the problem. [DELETE THIS SECTION]

S: One other reason could be the feature is already there. For instance, let’s take a simpler scenario. Where you’re solving a problem but it was too obvious. I gave you a factorial problem and you stuck in the abstract solution the very first time. And you write a test which actually says abstract solution and you catch the boundary conditions, the edge cases, when you add those tests, the abstract solution handles those cases as well. So when you add new tests, it’s still green.  So it’s still passing because the system already satisfies the behavior that you are expecting in the edge cases.  But how do you know where your since your test test-- does not have a test, to prove its correctness?  How would you know? This is actually happening because of the edge case.  Maybe it’s because of something else, maybe your test-- How do you know the test does not have a bug? If it’s green-

A: You would have to modify your code to go back.

S: Exactly!  You modify your production code.  For the edge case, you could just short-circuit, return an an unexpected value. Make the test fail. Then I know, okay, it did happen because of edge case. Now you went red and then you can go back to green again. So this happens when you’re actually faced with a situation where you go into a project, it does not have any tests, it’s a legacy system; you want to add tests. You have to go and mutate the code to make it fail because the code already exists. And this is one of the problems you have when you have a test last situation. Because you may have to comment out the code and you may have to mutate the code, change the if/else condition and make it into true or false. You have to mutate the code based on what you’re testing. So we saw this situation going green to green. When something is blinking and it’s green is blinking, you stop and think, you need to do something. You want to make it go red and then go back to green.  Next is-- now, what is this blinking yellow? If I have blinking green-- what does yellow mean first of all?

A: You said some kind of compilation/configuration error.

S: It could be compilation or configuration is not done, those things you still have to fix them.  So you still have to fix it so you still have work to do. Blinking yellow means you can’t proceed further.  Fix your syntax error, fix your configuration and you can go to the next stage, which is red.

A: How are you guys recording them, the results of your tests overall? Are you commenting them into the code or are you keeping them on a separate book or how are you doing that?

S: If I’m writing a code from which I am writing from scratch, I would just comment on the code because I am more intimate with the code. 

A: I would think that’s a lot easier.

S: But if it’s a legacy code, it’s very difficult actually. It depends on the situation. I can’t give you a generalized statement.

A: What do you do to finalize legacy?

S: You know how Heckle works?

A: More than five years old?

S: Legacy-- I consider anything that does not have tests a legacy system. Probably some of you here might have used Heckle. Code mutation tool, right? So we can look at-- basically Ryan Davis wrote a gem, and if you already have a test, let’s say you have a coverage of 80%. You run Heckle on it, it runs and mutates your code.  See, I know my tests are valid if I break my code, the corresponding test which is testing for something should break.  It should break for the right reason.  It should pass for the right reason. That’s how I know it’s working. And you do it once and manually. Because we don’t have a test for our test to prove its correctness. So we already solved going from yellow to yellow. And what does this blinking red mean?

A: Code's not behaving the way the test is coded to expect it to behave.
A: It's still failing. The code is bad.

S: Yes, it’s failing. This thing happens when you have some dependency on-- maybe you have data dependency, context-- your test is too big. There is test dependency and test data pollution that could happen because of that. Another reason is that you are building your framework or you are upgrading your RSpec or Rails or something or a major upgrade is going on. And it takes an hour or two hours to actually re-factor everything right, to the new method. So you will stay red-- those are exceptions actually. So you focus mainly on getting red to green really quickly. Exception is doing an upgrade, so you can’t avoid them.  But you still need to stop. If you’re not doing a major upgrade and you’re flashing like this, it also means your test is too large basically. You’re testing too many things at once. You need to test one thing at a time. Take smaller steps. That’s the feedback mechanism you’re getting when you’re having this red. You’re not progressing basically. Have you ever had the feeling of when you’re driving, all the lights are green, you’re just driving and green green green, you hit the highway and you keep going?  That is the next thing actually. This is the opposite of that. The next thing is like-that’s what we saw : green green green. You re-factor the code, you re-factor-- you actually-- re-factor the test code, it’s green green green. You re-factor a lot of tests, you have like 5, 10, a suite of tests, now we see a lot of duplication emerging, you abstract away all this duplication, everything is green green, okay, you are cleaning up the test code.  You could also be cleaning up the production code as well. And you are like green. 

So we have covered all the blinks. Let’s now look at all the other variation. So this is not really going, the secret of the traffic light, you’re going to go opposite. It’s going counter-clockwise. Instead of going clockwise, we are going from green to red.  And then red to yellow, and then yellow to green. So let’s take the first case. Going from green to red.

A: So what you're saying is, the way we want to go-

S: As a traffic light.

A: We want to go as a traffic light or we want to go as opposite of a traffic light?

S: Opposite of a traffic light. We always want to-- traffic light is the test first development, that's how it goes. 

A: And in the maintenance, you go the other way?

S: Red, green, re-factor, remember? Red, green, re-factor. That’s like a misnomer. You have two colors, you have red, you have green; where did this re-factor-- is that a name of a color? Doesn’t make sense. That’s why the test first programming, that’s why this third color has been introduced. It makes sense. For each step, what you need to do. The traffic light progression is the right way actually. Everything is going smooth. Just cruising, basically. When you follow the traffic light, no accidents happen. When something is blinking, blinking yellow light, you’re supposed to stop, look around, and then go. Same thing. You fix your syntax errors, you fix your configuration thing, you have the right library, no versioning issues, you fix those things, and then you can proceed. Flashing red light. Flashing red light is again stop. Look and then go. Flashing red light is basically, it’s giving you feedback. You basically use it as a feedback. You should be aware of what these things are. When you’re coding you also need to know what is the right action, step to take. 

Because I’ve seen a lot of-- these concepts are simple to understand. I’ve seen a lot of talented, very experienced developers actually staying in red, not because of exceptional cases where they are doing an upgrade, but they are just taking much bigger steps than required. Because they’re getting over confident. 'I can do this.' It just means when it’s red you need to take smaller steps. So, let’s now take a look at the first situation going in the non-traffic direction. Going from green to red. You were green and you wrote a test, it just means you did not go through another intermediate thing. It was not allowed for some reason. You did not make any syntax errors. Right in the beginning you will be having all these configuration issues and all those things initially. Once you are set up, once you have some test coverage, you are going to actually build momentum. And you get familiar with RSpec API, in likelihood you won’t make any mistakes. Most of the times you will directly go from green to red.  The test will be failing for the right reason. This is fine. 

So what about the next situation, where you are going from red to yellow. You were red and-- Think about this for a minute. You were red. Red was because of the right reason. You were actually failing, but you went to yellow. So what does this mean? What happened?

A: Failed the test?

S: After red what do you need to do? If it’s red, I am failing for the right reasons. 

A: You fix whatever you need to.

S: Yes, because you made a syntax error in the production code. Mismatching do-end block or something is wrong in your production code. Fix that, it should not happen, if it does happen, you made a syntax mistake. Correct it and you’ll get back to green. The last one we’ve already seen. From yellow to green, that’s fine. 

So, writing a failing test. This is making a transition to itself. You made too many syntax-- you have a syntax error, you have a configuration error, you make as many-- one thing at a time and then once you fix it, it’s failing for the right reason, then you can go to the next step where you’re red and you write the production code to go green.

 And we already discussed about this: you’re re-factoring and you’re green, you have suite of tests 10, 15 tests, now you’re seeing all the duplication emerge. You want to clean up your test, make it more readable. It’s green and you end up, you are still green. So here is all the different combinations of what we might have. This is the production code and this is the test code. The production code is very well-designed. The test code is not. The production code is not very well-written, but the test code is really written well. This is difficult to accomplish, actually. The test code is always-- if you write tests after you have written the code, your code-- production code actually dictates your testing code and it makes it very difficult to write clear tests. If your code is nasty, it’s very difficult to accomplish this and obviously you want this-- our objective is to have production code which is good as well as well-written test code as well. The fourth case, you could just change your career if this is the case. 

A: Unfortunately, in a lot of the large long-term projects, the Four is usually the case.

S: Exactly. You are in this scenario-- in real life projects, this is like an idealistic way of-

A: You almost never see that.

S: Yes, almost never see-- the bigger the company is, you either are in this situation. The code is nasty, but the test does not exist, or the code is nasty but you need the code. But you need tests for them for your own sake. And the organization has a lot of-- you need to spend a lot of energy to get this thing into the culture of the company. You are stuck at this level two or level four. This number three is more like a fantasy world. 

So quick quiz for you guys. What does this flashing yellow light mean?

A: You still have some kind of syntax error, some kind of configuration

S: In the production code or in the test code. Could be both. Or one or the other. And you fix it, and you will go into?

A: Hopefully red.

S: Yes. And flashing red light, same thing. Flashing red light, you’re just taking much bigger steps than you need to. So the thing about TDD is it allows you to-- you know how the rock climbers actually climb? It’s called three point contact. They have four limbs, always there is only one limb free at a time and they take very small steps on things that they know. 'Okay, I can keep going up.' The same thing happens here. Either you work on actually getting a code that works or you focus on actually re-factoring and cleaning up the code. You focus on one thing at a time. It’s very similar to that. It allows you to take very small steps when you need to and if you’re confident and everything is going fine, the traffic sequence is going fine, you can go faster. It doesn’t always mean you should triangulate. 

For example, there are like three different ways to solve a problem. One is. the problem is so familiar to you, you just type the obvious implementation. Other one is 'Fake it till you make it', where you hardcode something and then you make the test force you to abstract the code, and then you can triangulate. The term triangulate comes from the mathematical terminology where you take two different measurements with two different angles and you measure how far the ship is from a given point -- calculate those things. When it comes to TDD, triangulation basically you have different examples, and you keep writing, make the executable example, and each example will force you to drive out the abstract solution of your eventual solution to the problem. So now I’m actually going to go quickly over this red green re-factor and just show you how this thing works in practice. 

S: So this is Bowling game program is actually from the RSpec homepage. So I start off with a test. The code does not exist yet. The green. From here, I just start specifying the behavior. I’m describing this Bowling, if it is the Bowling spec. Where am I right now? I got an error message here. So what is it saying? It says 'uninitialized'. 

A: 'Uninitialized constant bowling game.'

S: Yes. So what is it complaining? Is this failing as expected? Is this red or yellow?

A: Yellow.

S: Yes, it’s more like a syntax. It’s not a behavior that is missing, it’s more like a-- you’re describing a class that doesn’t exist yet. So now I’m actually declaring the class that I need. Now I’m green. Where the test does not exist yet. Now I’m writing a test. This is an example of the bowling game. What I expect the bowling game system to behave. So it’s really just a pending example which is yellow. I haven’t done anything yet. Sometimes it just happens, you have so many things to do while you’re sitting in front of your computer, while you’re wanting to do this thing, you just write like a list of things of you want-- you get it out of your mind and put it here, it’s all like pending examples. You can just work through your list one by one.

A: So what is “it” mean?

S: “It” is a method that takes a string and  your behavior, you’re specifying behavior of the system, what are you actually, what is the feature. And when something happens you expect something to happen. This is the behavior of the system I’m describing. I’m describing a bowling game and I expect these things to have these two different features are the way it behaves. It could be the same method in this case. 

Now I’m going to write the test. So I told you about three A’s, the step one of the three A’s is Arrange, which you are creating some objects. That is what is going on. You create some objects and then the Two-- Arrange, Act -- is where I am actually doing something to the system  20.times { game.roll } on the game object. And the third is Assert. And I’m asserting what the expected output of rolling the dice twenty times should be. What is the score. What is the expected score. So I’m red right now. The method was not existing. So I’m implementing the method now. Maybe the signature of the method is wrong, so actually fix the signature to take in the parameter. So what’s happening here? I just want to stop-- You know the role is actually what I’m exercising.  That’s the public API. So you discover-- it’s a discovery process. What is the API should be? And then I am calling this score, because that’s what I expect the score to be something when I have like 10 panes, 12 panes, and I miss all of them, the score is going to be zero. So that’s how I know I need a score, that’s why I’m actually implementing it because-- you write code as if it already exists. You write code you wish you had. You specify, Okay, I want this thing to be there, and then you go ahead and implement the method. So you have two examples. One pending. 

A: Can I ask you a question?
S: Yes.

A: Why is it important to just do the minimal amount necessary? Because like, putting that zero in “score”-- I never get that.

S: Very good question. That’s the “fake it till you make it.” The way I was doing it-- the way I solved this problem, returning zero - you’re returning hardcoded values. That’s not a real solution. That’s not going to work for all input. The reason you’re doing it is “fake it till you make it” is one way to solve the problem. This is helpful when the domain is unfamiliar to you, the problem is not a familiar problem. Everybody knows Factorial, Fibonacci, those things, and you can just type in your obvious implementation the very first time. Obvious implementation is one way to solve the problem. If the domain is unknown, it’s a very difficult problem, and you haven’t encountered a problem before, this “fake it till you make it” is what allows you to take small steps. It’s all about breaking down a big problem into smaller pieces and decomposing the bigger problem into smaller pieces and solving one problem at a time. One example, writing one executable example at a time. 



Start from 42.07 of the video 1.




You don’t write the very first test to write a very abstract solution that handles all [edge SS] cases, all the chronic cases. It allows you to focus. Just because the TDD allows you to take baby steps doesn’t mean you always need to take baby steps. You can take longer steps if like I said, it’s familiar problem, you already know how it works, you’re confident you can go faster. 

A: So it’s like making the problem more digestible?

S: Yes, it’s making the problem smaller and smaller until you can make this thing pass. “I know what I do next.” When I showed the video the professor was talking about, if you just act, “What do I do next?” Sometimes you’re stuck, right? Where were we? I don’t know. What should happen if this thing happens? You’re changing the context. You’re handling-- you may be like, when you’re solving a problem you may have so many different things to worry about, but this allows you to focus.  Okay, this particular scenario, this particular thing, I expect this behavior. You added on [SUDs SS]. The test becomes smaller. You always add on SUDs, the smallest thing, and you make the test one thing and one thing only, you don’t have any overlap in the test, tests are isolated, and [0:43:37 SS] in any order you want. I’ll be going over them in more detail.  So does that answer your question?

A: Yes.

S: The second one also I’m implementing is kind of like-- the first one-- one more question is, How do you pick the first test to write? What should be the first test you need to pick? If I give you a problem, how do you go about writing the first test?

A: Well, usually I know the subject that I’m dealing with, so I’m usually given some specification by a project manager, says, “I need the system to do this.” So, I break that down into some architectural diagrams, come up with some method signatures that I know I need to test, and go from there. 

S: Okay, let’s say once you decompose the problem, you did a little bit of design, that’s okay. You didn’t spend a lot of time up front on design. And you typed in a code like 5 or 10-- let’s say like I did, pending a to-do list. You have 10 tests to write. Okay, you’re at that stage. Now how do you go about picking which one of these? Should it go on the first one, the second one, how do you know which one to pick on the last one? Which should be the first test to write? 

A: I would always start with the interface, defining my inputs and my outputs and whatever it is. 
S: Getting close? Closing up?
A: [Mumbles]
S: This is the very first test, so think a little bit.
A: Seeing what happens when you pass [null SS] into it unless you give it small integers and things.

S: Exactly. Edge cases. Because it’s very trivial. What does it prove? It just proves you have all the required statements, you have your environment, you have the framework, everything working. So you’ve tested [0:45:37 SS], still everything’s zero, blank screen, something which is trivial, which is just a way to get things going. You’re trying to build momentum. You’re taking your first step.

A: Eventually what has taught me a number of times-- someone comes in after my code, passes in, null or substantiates my class with a null and the whole system detonates, so it’s like-
S: Crashes.
A: Yeah. And so, obviously testing with null the first time around or null string equivalent-
S: Yes. If the class that you are testing is-- you are the owner, then you start with the [pausing and alpine SS] exception. If it’s some other library, then you should obviously [pick SS] a blank screen which you know it’s not going to crash. The main purpose of the first test, making it trivial, is to get your entire environment 0:46:32 SS] and everything set up. So you can keep on moving.  [0:46:36 SS] write more tests. 

It also allows-- it’s basically a learning process. As you start writing tests which are trivial and then you gradually increase in complexity, you learn more about the domain. You get more confident. And you can actually-- it’s progressively getting more difficult; you can solve much bigger problems. You carry more understanding, better understanding of the system.  So, I’m going to go faster…

A: [Inaudible, laughter]

S: Basically I’m just re-factoring the test right now. The test-- everything is the same. When I’m re-factoring, I keep all my tests. I have a safety net now. And I took all this production code, I moved them into a different file, I solve the clean code part later once I actually solve the real problem at hand.  Now I have this “before each”  and doing all kinds of [plan murky SS], the later stuff, where I [write? wire? SS] the duplication in the test code. Because I want to [create? treat? SS] the test code I would treat the production code.  Because we have to maintain the test code also. And basically this thing is going to-- I’m going to evolve. Before each-- instead of before each, I’m going to say “game,” because I don’t want to use instance variable, and then I have this “odd equals EDM” where it’s [0:48:57 SS] it’s already there, I just return the existing instance. And then this is going to evolve into led, led syntax, where I say led can be equal to this. And let basically is-lazily initialized some variable you want to use. Unless you use the variable, that won’t-- that led block won’t get executed. So it’s a little bit different from “before each.” That’s the end of this TDD demo. The thing I want you to notice is, what the heck is this “20 times game dot roll” doing here? This is not-

A: Rolling it 20 times.

S: So what should I be getting about rolling 20 times something here in my test?  I want to specify behavior, not implementation. So all this [youth SS] logic, having loops like this in your test is a bad idea. This is not an example of code even though I took it from the Rspec home page. If this is how you begin your test, your software is going to rot faster than you can imagine actually. When you write your test you only think about specified behavior. If you specify behavior, you don’t think about HOW of doing something, you only think about WHAT. WHAT the system should do. 

Let’s consider this thing. Let’s make this better. This is a bowling game domain. So what am I doing here? I’m getting all zeros here, in this case, scenario. Let’s say I strike everything. All that [pains SS]. It’s a strike. In the domain it’s called as a strike because I hit everything. If you miss everything, probably it’s a flop, a miss. So if it’s a domain-specific [time SS] of structure missing, that miss or strike is what you need to specify here. That is the missing interface you have to discover and implement it in your interface. Because your test should only focus on specifying behavior, not on implementation. You have to hide this implementation in your production code behind the well-defined interface. That makes sense for this particular domain, like miss or strike, you may come up with something else for your scenario. I want to actually give you guys a chance to go through this TDD thing, so let’s work out a problem where we have a factorial--

A: It says noon now, do we want to break and then come back?
S: Yes, maybe a 5, 10 minute break?
A: Oh, it says this had a one-hour lunch break. It’s noon now.
S: It’s noon now? Okay, it’s your choice whether you want to take a 30 minute lunch break, whether you want to grab something to eat here while I actually keep going, so you can go home quicker, it’s up to you guys. Or you want to take a one-hour lunch break. 
A: How long is this exercise going to be?
S: At least a half hour. The factorial-
A: You want to break at 1?
A: I can break after this, if it’s a half hour. I drove myself insane with the attributes passing the… [0:52:35 SS] because having to put all my parameters from the Java Script site into the right screen format so the variable names automatically fall through to zero code, it’s like, “okay, I’ve got to name it with this, underscore it with this,” and it all has a test, it took weeks. But once you got it to work, because Rails and all that turned into the right data structures and dumped it right through to the zero code in the back end, it was all on the [weird SS] front end, the nested attributes, but it was just mind-bending. But yeah, once it works, it’s rather cool. 

S: …instead of an underscore can drive you nuts.
A: Yeah, but this is [0:53:10 SS] got the underscore the sub-model, underscore this, but not-
S: We are almost there guys. I actually only had 70 slides in my first workshop. This one is like 110. You guys have been like-
A: Are these slides available for us here afterwards?
S: Of course.  I can email it to you guys if you want. I can upload it to the file section. One more… Any questions so far over what we have done? We have like four or five slides to go through and then we work on a Kata. I’ll give you a Kata and a USB drive and you can just copy it. And it has specific instructions for what you should do and the rules. And I’ll let you work on it and I’ll help you guys to work on it.
A: Is that the same file that’s on Github ?
S: TDD Kata at [THD SS]. You should be able to go to the meetup.com and-- You guys were able to connect?
A: Shut you off…calculator thing?
S: I put up a link to the Github right? 
A: Yeah.
S: Okay, if you want we can make it a little bit closer to you guys. That way you don’t have to-

S: So we already saw this payment strategy and how they’re using this for in combination with Mox. The next thing is mix-ins, plug-ins. How they are using the steps. One more thing is not just mixing the plug-ins. You can also use the steps to speed up your tests. Now what’s happening is a lot of people are taking all the business logic not just in a model. Initially it was all about thinking in a fat model. Now the fat model is not fat anymore. They take the business logic out in its own modules. And you mix them into your steps and you test the behavior that way actually. 

> Because once you have a module that can be mixed in anywhere, you can just take a step and then mix it in. So in this case, the mix-ins and plug-ins, we have an age identifiable. This is a role. When you have a mix-in or plug-in, this is very similar to interfaces in Java. So we have a module card each identifiable, so it’s a role probably.  So it has-- [Canword SS] is one other method in that interface. These are the behaviors: it raises exception if 'including' does not respond to birthdate. It must supply a birthdate, otherwise it cannot determine the user is qualified to Canword method. Basically create an instance of the object, and extend with the module that you actually have the behavior. Age identifiable. This object is nothing but a regular object. It’s not really active or [0:57:10 SS] or anything. The same concept can be applied to your active record models. You can just say, instead of object, it will be your user or some other character, and you extend them with these identifiable behavior.  And then this “expect” is basically post condition check in the [beginning SS] account terminology. It takes a block, this code within the block, it gets executed, and it checks, after it gets executed what’s going to happen. After an object in Canword is executed it is expecting to raise error, and that error is going to have a message: “must supply a birthdate.” So the second case, if it ends true that your birthdate is 18 years ago, because they are valid and they can work. You create an instance of an object and you’re stopping that particular object-- the birthdate method. The birthdate method is stopped and the [0:58:14 SS] is 18 years ago. So this person is 18 years old. It will respond to birthdate. In this case it will not rise an error, an exception, and the Canword method-when you call this, it’s actually you can make this Canword method be true. You can just make it as object. You can even say should be underscore word. Since it’s like a Can underscore word, I think this is a better way-- that’s why in this case I have done it this way. 'Object can word question mark should be true.  Because yes, they can. You also have to test the negative [tradition SS] like you were saying. 

You will always test the golden path.  The golden path-- you don’t really test that much at the custom test level at the [Kukermer SS] testing level. But you should test all the negative scenarios. All the automators, at any test level. Because it’s isolated, it will run fast, and you need to make sure it can also work in the negative scenarios as well. 

Message expectations-- okay, one more scenario where you can actually use Mocks-- it’s the side effects that we already discussed. Side effects is like putting some message into a queue or sending an email, there is no state change. Change is the state of the system, but there is a side effect. There is an outgoing message, that’s what I mean by side effect when I do this.  
1:00:00 


