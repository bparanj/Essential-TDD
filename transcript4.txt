[Continue video 3 ("TDD bootcamp part 2") at 0:45:37]
S: You can only go through this public API. There are methods available that acts upon this state and provides certain services to other objects. And there is another object and this object cannot do everything by itself. It needs to collaborate with other objects. It has to send messages to other objects to do its task and return some result, do-- it has some indirect output or something. 

You follow the good OO principle, you encapsulate, you follow the encapsulation, its abstraction, all those things, well-designed objects. If you have all the well-designed objects, you also need to make sure the communication between those objects are also well-designed, like for instance, you always depend on the something which is more stable than your abstract. Don’t depend on concretions like solid principles and all those things. So you have-- you cannot have just one or two objects. Basically your domain model will be having multiple objects, so they’re web of collaborating objects. It’s just a graph of objects. This guy is independent of everybody else. Everybody else uses services provided by this guy, and this guy’s services are used by these two guys, and this guy is eventually using this guy, who in turn uses all this. So you have all these different communication paths. Look at all this communications going from one object to the other. In a well-designed system, you’ll be very careful how you design this messaging between systems. 

If you see some Rails code project, you’ll actually have this, this, this, it’s like a violation of law of Demeter -- foo.b.a.x--  you just keep on chaining them to the-- it’s a train wreck basically. In a well-defined interfaces-- if you have well-defined interfaces, they provide some services. That’s all you need to know. The public API-- you just use it, that’s it. Don’t just keep on grabbing data and chaining calls forever. Unless you have very good reason to do so. So if you design those services provided by the objects properly, you will think about what is this interface that I need to provide? I need-- I want to fulfill my responsibility as some object b here that does not exist yet. 

Maybe Karen is working on it right now. But I need to write my object a. I cannot wait till she is done. We are working in parallel. So I can replace it with mock. As long as we have agreed upon a well-defined interface-- okay, we have agreed upon this thing. She has told me these are all the arguments. I’m going to pass through, and she’s going to give me this result set. I only program to that interface. The mock is basically going to comply to that interface. When she is done, I can use the real object. 

The integration test has to use a real object. It can’t really use a mock when you write a customer test. It has to integrate all of the layers together. So it’s a way to discover the interfaces. I want to discover this interface. What is the role that this object plays? And then I need another service from another object. I gradually discover all the different interfaces I need. 

Okay, Gabriel is working on some other thing I need from him also so I have another contract with another team. And I start using another mock to replace Gabriel’s module. And so on. So you have all these different interfaces. These are all the web of objects collaborating through roles. Not just interfaces-- you want to find the roles that objects play. The main point of using roles is basically-- it allows you to compose objects in different way. 

Let’s say I have a person object. Person object can play the role of a student, it can play the role of a son, daughter, all these different things. But you’re playing a different role. As a student, I have a certain set of responsibilities. Study, pay attention, all of these things. Those are all methods, responsibilities; those are all methods. Played by that particular role. And if I don’t attach it to a person object, I can take that particular role, student role, and I can give it to a dog object. It can be a student now. Without even changing the system, I can pass a dog object to the system. I compose the run-time behavior object composition will be different. Behavior will change. Because of the duck typing, everything will just work. You need very minimal-- even if you need to make any changes, very minimal changes in the code is required. 

S: So CRC. In XP we use CRC cards for doing design; there is no UML modeling, all this thing. It’s a very agile way of actually designing it. Here is a game engine. This is a candidate class. These are all its-- the column on the left is all the responsibilities of this candidate class. It displays game state. This is a role. Again, this is a responsibility. This is the role which collaborates with the game engine to accomplish this particular responsibility. 

These are collisions, all these things. So this is a candidate class, and these are its responsibilities. And these are its collaborators. Instead of CRC class responsibility collaborators, you are to start thinking in terms of-- move toward thinking in terms of roles, responsibilities, and collaborators. Renderer it could just be a role. Animator is a role. Collision detector is just a role. This way I can actually swap different implementation of collision directors. I can have a fake collision director where I don’t really want to incur the expense of running a long-running test. I can actually have a fake animator and it‘s just not really doing a real animation; it’s just faking something. Makes my test run faster. 

So you are basically designing for testability. You can plug in different things, you can combine different objects in a different way to accomplish-- customize the behavior of the system. So if you think about this, Unix is based on the same principle. There you have pipes. You have cat, you have ls, piping where you can redirect output to some file. You can use those small utilities that’s focused on just doing one thing, but when you chain them all together, they accomplish a much bigger task.  We want to do the same thing in OO programming. We want each object to be focused and very cohesive and highly cohesive and loosely coupled. 

So if it’s loosely coupled I can combine them just like Unix chaining together. I can combine these objects in different combinations and I can accomplish-- I can satisfy a new requirement that I didn’t really think of when I wrote this code. But tomorrow’s changes that’s coming in down the pipeline I can actually satisfy the requirement using existing objects. I can reuse them in different contexts. 

So let’s consider. Okay, we have our graph of objects. Let’s just assume we have all these communications-- it’s not like haphazardly going to each and every thing and just like spaghetti-- it’s well-defined, well-designed services. Each object provides services. Let’s just focus only on this guy. See what’s happening-- if I want to test this guy in isolation, I have some services being used by this guy. I have some outgoing messages. I have two guys coming in. In order to test this in isolation, I have to actually-- it replays this entire thing-- actually environment, it’s going to actually resemble as it-- these guys are providing-- if I need something from some other object, I’m going to replace those guys with something which is going to be like a fake, that’s going to run faster in actual test environment. In actual production environment, it’s going to use the real objects. So if I just consider one object, I have incoming messages, I have outgoing messages, and I have messages sent to itself. 

So we saw indirect input, direct input, indirect output, direct output, and now the different combinations. What is this message-- the object is sending a message to itself mean? If it’s an incoming message, I have provided some services to others. It’s in my public API. Everybody can see this. It’s a well-published API. All of these outgoing things are invisible things I made-- depending on some other component’s result that’s going to come back. For instance, if this is a shopping cart, let’s take a concrete example: shopping cart. And somebody-- customer just selected, in the shopping cart they put a product into it. They said “add” and they provided a parameter: “okay I want to purchase this book,” and they said “I want one book in this.” One book is in here.  Eventually, they say, “I want to check out.” To the shopping cart. But the shopping cart in the checkout, what it needs to show them is, how many books did you put in your shopping cart, what is the price, what is the quantity. It also needs to show how much you’re going to pay for the shipping and handling. Shopping cart-- that’s not the job of the shopping cart to do the tax calculating. Tax calculating is somebody else is going to do it. That’s the dependent-on component. Tax calculation needs to know what is your state, what is the weight of the item that’s going to be shipped, so I can calculate based on that geographic location, I can give you what the tax calculation is. I can just give you, okay, this is the amount, what is the total amount you want to charge tax for, this state, this weight, here is your tax. Somebody else is going to give-- this guy is going to ask, this is my total weight, this is the state where this customer belongs to, please give me the tax. It’s going to ask him. This is the indirect input that it requires in order to go on actually provide the line-item display that the users can see from the browser. 

That’s another concrete example of indirect input required by this guy in order to fulfill his public API. Services he’s providing an API. So this way, I can actually stub out the tax calculation. I don’t really need to go to the database, to find the geographical location, six percent is the rate at which I need to calculate tax. I can actually fake the entire thing. So my test will run faster. So we already saw the test-- when you actually write a test and you’re going to actually test a particular object, it’s going to depend on certain services of something else. If it’s a parallel development, some other team is working on it, you don’t even know that it even exists-- it doesn’t exist yet or someone’s working but you need them. What are these? You need to have your test written for your thing that you’re working on. That’s when you actually replace them with mocks. Those things will also be-- you have more control over it, as long as you have well defined interface-- you can actually complete writing the test for your particular module. So, any questions on the messaging thing that we have already seen before we move on to testing guidelines? You always use the API first. Use the front door first. The public API is also called as the front door.
A: Will you be giving us examples that [0:59:11]  Will you show us an example?
S: Example for?
A: For interacting with third party service, let’s say you’re using SUT or-
S: That-- I have a diagram for that toward the end of the thing. I have a diagram which actually goes over it. 
A: [0:59:35] External resources.
S: Yes. Anything that deals with external resources. I’ll tell you whether you need to stub or mock, when you actually have to integrate, how we will do it-- all this-
A: So the summary of this section was, If you are having any third-party interaction, just mock that?
S: No. Don’t mock. Mocking is all about-- coming to the mock with the entire section on mock, you don’t mock a third-party library. Because you cannot drive the design of a third-party API. If you have authorize.net, paypal API, you cannot mock them because you have no control over what they are doing. But what you can do, you can stub them. You have more control over them in your unit test. In your unit test, you will stub them. 

But for integration test, you have to actually write a test which is going to hit-if it’s Paypal, it’s going to hit the test send box. Just to make sure your system can interact with their external API as of now. When somebody comes-- if I go into a project, somebody gives me a Braintree, say here is a Braintree API, I don’t know how it works. I want to learn the API. So write tests. To make sure your understanding of how the API works is valid. Once you have the test that’s specific to that version of Braintree, where Braintree 1.0, Oh I have learning tests. That’s more like integration test. What is the value of having that? When Braintree comes up with version 2.0, if some of my tests fail, I need to fix them. Upgrade them. Because my code eventually will fail because it’s different from those assumptions. Whatever changes I make for that learning test for the API, I need to make those changes for my dependent object, that particular layer. You actually need to have a very thin layer. Your domain model, you’ll have a very thin layer of adaptor that’s having well-defined interface that you have control over, that you can mock, but the thin adaptor will adapt your domain model to the external API calls. So this way you insulate the changes from the third-party changes, they have their own release cycle. I don’t want my department to be impacted by somebody else’s schedule. I want to have more control over it. That’s why I isolated it. This is like anti-corruption layer. This way I decide when I want to upgrade Braintree. When I run all these integration tests, if all of them pass, Oh, no problem-- it’s backward compatible. Just because he says in the documentation, Read me, it’s backward compatible, I cannot rely on it. Because I don’t want to risk my system blowing up, customer not being able to purchase item on the site because of third-party, I cannot blame it on them, right? So I need to have the testing that needs to give me the confidence of okay, If I upgrade this, if all of the test passes, I can guarantee none of the changes will impact our code base and we can go ahead with upgrade process. 

So we can pinpoint, okay what is going to be the impact of changes? Instead of saying, I don’t know, maybe we’ll upgrade and see if everything-- I don’t really know what the impact of changes will be because you cannot really determine, unless you have a test suite that you can run automatically at your command when you want to run it. Then you can pinpoint, we have so many tests breaking, some are serious things we need to really look into it, we cannot upgrade right now. No. We need to hold off on it. We cannot upgrade right now. You can make the decision. I’ll show you that layer and I’ll be talking about them then.
A: I’m still confused. So you’re saying all the real service [1:03:22]
S: Your question was, How do I deal with external web service. External -- you don’t mock, you stub them. You stub them in your unit test so your unit test will be faster. Because you should not be going over the network in any of your unit tests.  You should not waste resources. 
A: I’m just confused about mocks and stubs-
S: I’m going to actually-- I have a 60 minute session on stubs and mocks. And then it will be more clear when we revisit the topic. The one other thing is, challenges, all this material-- it’s not linear. But I’m trying to gradually build you up to it, so everybody’s at the same level. Once I start discussing those things, everybody will understand what I’m talking about. Otherwise I will be jumping the gun too soon. Which I don’t want to do.

 Okay, right now let’s look at some testing guidelines, like Gabriel mentioned, during lunch I know some of these things. Yes. Because you know what you’re doing. These are guidelines to get you started. They are there for a reason, but if you have to break them, do them for a valid, sensible reason.

 The first one is, don’t modify the system under test. I’ve seen this thing-- a lot of people actually-- we have a lot of tests, for instance, in one of projects, and suddenly some test started breaking. So what he did was, he went into the production code and he put this if Rails.env  equals test, skip this line of code. So what he did was, the system under test is basically a production code, and he’s changing the behavior of the production code to be different in the test from what is in production. If we start having these kinds of conditionals, band-aids, in your code, eventually it’s going to create more misery than solve any problems for you. So you have to be very careful when you put all these band-aids in there. But Rails already gives you test mode, you have all access to this thing, you have a test.rb. It’s like a specific configuration for testing. You have specific for production, and you have specific for development. So you configure according to environment, but don’t change the source code and put band-aids in there, because it’ll cause problems later. 

Keep test logic out of production. Basically same thing. Band-aid everything you don’t put like if Rails.env -- like we say do this otherwise we do something else. It’s just going to get a lot of problems down the line. This also can kind of-- we discussed this thing over lunch. Gabriel was talking about this.

 Effort versus responsibility. Commensurate effort versus responsibility. What does this really mean? It’s effortless. It falls down. Because of gravity it just comes down. It’s so easy. How much effort does it expend?  Not much and it doesn’t weight that much. The thing is, when you have a production code and you have like four lines of code, you should not be having like a 10 or 15 lines of test code to test the four lines of production code. You’re expending so much effort to actually test something as simple as four lines of code. You’re doing something wrong. If you’re doing it, do it for valid reasons. “Okay, I know I’m breaking it. I’m doing it because I want to increase the communication. I want the communication benefit to be emphasized. That’s why I’m writing four or five tests for just four lines of code. That’s fine.” Or my confidence level in that code is very low. This is very critical part for my revenue everything generates because of this purchasing part of the code. Even if there are just four lines of code, I don’t want my purchasing system to have-- I don’t want to lose money basically. You have lot of things to lose-- monetary-wise you’re going to lose a lot, then it makes sense. 

You always think about, okay, if it’s just one line for instance, Rails has like one line, one active support uses a lot of very high level APIs. If you can just write one line of code, it makes a lot of things easier, even tests, if you know how to use the right test API, you can just do one assertion, you can just test everything instead of trying to do four lines of code. Always weigh the effort you’re spending on testing something versus what you’re actually testing. 

S: So now we will come back to this TDD, BDD, behavior driven development, all these buzzwords. So what you did in the morning exercise is basically a state verification. What you did was-- the method was basically a stateless method. You provided some input, you got some result back, you verified that state. Okay, what was the state at the end of the particular call? Was it what I expected?  That’s what you checked. 

So in the setup in this case, in your case, the setup was creating some object. It was for some of you, you created an object and you had-- you called that method on it. Some of you had like a class method, so you did not have to create any object. And in the exercise phase, you actually called your sequence or number or those things, passing in the value. That’s when you exercised your Fibonacci, which was under development. You discovered the API. “Oh, I want to call this as a number, I want to call this as a sequence.” What did you verify? The result that was returned back was the direct output. From the Fibonacci thing. And you checked the verification. Result should equal equal zero, one. You did a state verification. That is an example for a state verification. All this thing is grayed out because-- all these are invisible, you ignore them because it’s a direct input, direct output. 

And Fibonacci is the only method you were testing. It was not a cluster of objects. This is state verification, and this differs from behavior verification. What is the behavior verification? You have an object that’s calling this object, this in turn uses services from this object, as well as this, this guy is sending messages to these two guys. If you see this, these are all black. I don’t care about the state. What is the state? This is the black box. I don’t care what is inside this object. My focus is only on the messages that is being sent between objects. In Behavior verification, I care only about these messages. That’s what behavior verification is all about. You are not really checking what is the result that is coming out of some method call that you just made. 

Here it is. This is what it looks like. You still have the setup phase, you can setup, create objects you need. In the exercise phase, you invoke a certain operation on the SUT. See what happened in the invisible part. You cannot see this thing. These are all like indirect outputs, behavior. These are all messages going out. Outgoing messages. Initially I showed you: everything can be boiled down to incoming messages or outgoing messages. Outgoing messages says it’s dependent on component. This, this message could be going to a messaging queue. This message is going to a database, this is going to a web service. You want to-- if the charger just completed the purchase, you want to charge them. This is the customer’s credit card. Please charge them so that it goes into a certain queue and gets processed. It’s asynchronous. You cannot view it. Confirmation email is sent. “Here is your purchase.” Email has been sent to the customer. You cannot really see them, but you can assert on those messages and make sure, Okay, confirmation email was sent to the customer after the purchase was successful. The credit card charges was made after a successful of purchase. I did charge the customer, so I am not losing money. Because it’s important for me to charge the customer, especially when I am going to ship the product. So I have to assert on the messages. Okay, it did send the email, should receive confirmation email, something like that. “Should receive” charge customer, authorize.net API; that’s going to interact with the authorized.net API. That’s where you will be using all those assertions, behavior. So I already talked about the front door. Front door is the public API. Always use the front door, which means always use the public API where you will be doing calling all the methods, where state verification or behavior verification, you’ll be calling those public APIs. 

What is this back door verification? Back door verification is basically you just bypass the setup method, you directly go into the database in this case. You setup some data here, fixture, that you need, and then you exercise your system under test. You’re not actually-- depending on the result, this guy is returning. You’re actually bypassing-- you’re using the back door to verify, oh okay, is this what I expect this thing to be in-- state? Sometimes this actually solves certain problems with-- most of the time, state verification and behavior verification is actually covers like 90% of all the cases. 

So back door is used in very few cases. But you still need to know what this is-- this is available to you. And one other testing guidelines is you should not have any if statements, loops, nothing. I said it has to be so simple that even an intern who’s coming in could look at your code and say, Okay, I understand this. I get this. 

So if you cannot have an if statement, then what can you have then in your test? That’s where we have guard assertion. Instead of having an if for something, you create a guard. If condition is called a guard. Basically if sometimes if you don’t have a guard condition, your program crashes. Maybe you don't have a guard condition, that’s what we say. In this case, if it’s so important to you and you have to assert, have to have some kind of thing, make it as a guard assertion. So if the built-in API does not give you, just write your own and make sure you have that library well-tested so you can reuse it everywhere.  

And the custom assertion is-- some of the domain-specific thing-- for instance is not coming out of the general RSpec API. Sometimes you have to write your own custom assertions that are applicable for your business domain. Custom assertion or even the domain assertion.

A: What’s an assertion, exactly?

S: Very good question. Assertion-- let’s take a step back. Assertion is basically-- assertion can take any arbitrary expression. We will see a lot of different matchers in RSpec, what assertions look like. What kind of expressions you can have, whether you can just have boolean expression, whether you can have float point comparisons. Floating point numbers, they’re not precise. If you give me like $10 and 99 cents, and if I have $10 and 99 cents, if I subtract, but they’re still not equal to zero. So you have a delta assertion. You have different kinds of assertions. It’s basically stating a post condition. What should be the behavior of the system at the end of the exercise phase. 

[stop video 3 ("TDD bootcamp part 2") at 1:15:32]