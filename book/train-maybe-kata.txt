Train Reservation Kata


Problem Statement
=====
------

Railway operators want to :

1. Sell tickets online
2. Decide which seats should be reserved at the time of booking

You will work on the TicketOffice service. Your next task is to implement the feature for reserving seats on a particular train. 

Business Rules
------

- No more than 70% of seats may be reserved in advance
- No individual coach should have no more than 70% reserved seats
- You must put all the seats for one reservation in the same coach. This could make you go over 70% for some coaches, just make sure to keep to 70% for the whole train.

The Guiding Test
======
------

HTTP POST is made to the TickeOffice service with the form data:

- Which train the customer wants to reserve seats (train_id)
- The number of tickets

The service returns a JSON document detailing the completed reservation. The format is as follows:

```sh
{ "train_id": "express_200", "booking_reference": "24er92", "seats": ["1A", "1B"] }
```

If it is not possible to find suitable seats to reserve, the service will return an empty list of seats and an empty string for the booking reference. 

Command Line Option
======
------

You can write a command line program which takes the train id and number of seats as command line arguments and returns an ReservationConfirmation object with the same data as the JSON document above.

Discussion
======
------

We are going to develop the core logic of the system without worrying about how the user is going to interact with our system. This means we don't have to worry about HTTP, command line interface etc for now. This also makes the core of the system to be consumed by different user interfacing mechanisms without any modifications.

Steps
=====
------

Step 1
------

The railway operator has a service-oriented architecture, the interface you'll need to fulfill and some services you'll need are already implemented. The starting code for this kata is available from Emily Bache github repo. Get it by running :

```ruby
$git clone git@github.com:emilybache/KataTrainReservation.git
```

Step 2
------

We are given the interface for make_reservation in ticket_office.rb. Let's write a test for it in ticket_office_spec.rb as follows:

```ruby
require_relative 'ticket_office.rb'
require_relative 'reservations'

describe TicketOffice do

  it 'should make reservation for a given ReservationRequest' do
    request = ReservationRequest.new(1, 4)
    office = TicketOffice.new
    
    booking_reference = office.make_reservation(request)
    
    expect(booking_reference).not_to be_nil
  end
end
```

This fails with the error message, 'expected not nil, got nil'.

Step 3
------

Change the make_reservation method in ticket_office.rb as follows:

```ruby
class TicketOffice
  
  def make_reservation(request)    
    '1a3c5f'
  end
end
```

The test now passes.

Step 4
--------

```ruby
  it 'should give reservation confirmation after purchase' do
    request = ReservationRequest.new(1, 4)
    office = TicketOffice.new
    
    office.make_reservation(request)
    confirmation = office.reservation_confirmation
    
    expect(confirmation.booking_reference).not_to be_nil
  end
```

undefined method `reservation_confirmation' for #<TicketOffice:0x00000101816b48>


Step

ReservationConfirmation = Struct.new(:booking_reference)

class TicketOffice
  attr_reader :reservation_confirmation
  
  def make_reservation(request)    
    @reservation_confirmation = ReservationConfirmation.new('1a3c5f')
    '1a3c5f'
  end
end


The test passes.

Step


Delete the first spec, since it is superceded by the second spec. Also the first spec doc string was too generic, but the test was checking only booking reference.

Step

Since the requirement says the JSON document response needs to have the train_id as well as the number of seats. Let's add the next test as follows:

  it 'reservation confirmation should have train and seat details' do
    request = ReservationRequest.new(1, 4)
    office = TicketOffice.new
    
    office.make_reservation(request)
    confirmation = office.reservation_confirmation
    
    expect(confirmation.train_id).to eq(1)
    expect(confirmation.seat_count).to eq(4)
  end

This fails.

Step


ReservationConfirmation = Struct.new(:booking_reference, :train_id, :seat_count)

class TicketOffice
  attr_reader :reservation_confirmation
  
  def make_reservation(request)    
    @reservation_confirmation = ReservationConfirmation.new('1a3c5f', request.train_id, request.seat_count)
  end
end


Now the test passes.


Step

Let's replace the hard code booking reference number with a random alpha numberic number generator as follows:

```ruby
ReservationConfirmation = Struct.new(:booking_reference, :train_id, :seat_count)

class TicketOffice
  attr_reader :reservation_confirmation
  
  def make_reservation(request)    
    @reservation_confirmation = ReservationConfirmation.new(unique_booking_reference, request.train_id, request.seat_count)
  end
  
  private
  
  def unique_booking_reference
    rand(36**7).to_s(36)  
  end
end
```

We will assume this generator will generate unique alpha numeric characters. All tests pass. This change in the production code was not driven by a test. The implementation is hidden as a private method, so we will not write a test for it.

Step

Before we make the reservation we need to check if the seats are available. [Train Data Service](https://github.com/emilybache/KataTrainReservation "Train Data Service") section describes it in more detail. The input will be the train_id and the output will be a list of available seats.

```sh
{"seats": {"1A": {"booking_reference": "", "seat_number": "1", "coach": "A"}, "2A": {"booking_reference": "", "seat_number": "2", "coach": "A"}}}
```

We will use a FakeTrainDataService that will return a list of available seats as collections of Seat objects. We will ignore the Web Service calls for now.










 
