
Problem Statement
=========
---------------------------

Sum a set of numbers

Problem Domain Analysis
=========
---------------------------

Let's consider the set of numbers, numbers = (1, 2, 7, ... n)

Sum s = 1 + 2 + 7 + ... + n


Let's formulate an algorithm takes into account that computers can add two numbers at a time. So the algorithm needs to be repetitive.

s = a1 + a2 ------> 1
s = s + a3  ------> 2
...
s = s + (a)n 

All sums for n >= 1 can be generated iteratively. 

Solution Domain Analysis
=========
---------

Initial Condition
=========

We observe that for n = 0 and n = 1, the initial condition is s = 0.

Steps to Solve the Problem
=========

1. Compute first sum (s = 0) as special case.
2. Build each of the n remaining sums from its predecessor by an iterative process.
3. Return the sum of n numbers.

Algorithm Description
=========

1. Take the list of numbers to be summed.
2. Initialize sum for 0 numbers
3. while < n numbers have been summed repeatedly do
     a) Read the number
     b) Compute current sum by adding the number read to the most recent sum.
     c) Go to the next number.
4. Return the result.

Discussion
=========
---------------------------

We have solved the problem by giving the stupid computer specific steps to find the sum. Let's look at a different way to solve the same problem. 
  
Gauss solving the problem. Recognize the pattern.

How does [1,1] differ from [2,2] ?
Why use [1,1] instead of [2,2] ?
What to do when a test passes without failing? Why?
How to write a story test? Why?
Why degenerate test case is the first test?

0, 1, 2 and n elements

Establishing index and result values that handle degenerate cases.

If-else removed during refactor. 
While used to generalize.

Looking for transformations higher in the Transformation Priority Premise List.

Incremental Algorithm Design

Our algorithm can be implemented in any language.

Understand the Problem
  
Implement your own version of inject method.

Notion of Contract
When to throw exception 
Defensive programming. Why it's not a good idea.
Making simplyfing assumptions to delineate the scope of the problem

Assumptions
=========
---------------------------

- Numbers in the list are whole numbers
- Numbers will not cause stack overflow issues when added


Exploratory Testing 

```ruby
$irb
load 'sum.rb'
```

and test.

Why random data in test data is not a good idea?

Test Cases
=========
---------------------------

1. Why degenerate case first? Establishing initial conditions for loops.
2. Simple one element case.
3. Extend the solution to 2 elements.
4. Generalize to n elements.
  
Steps
=========
---------------------------

Step 1
-------

```ruby
require_relative 'sum'

describe Sum do
  it 'should return 0 for empty list' do
    s = Sum.new
    result = s.calculate([])
    
    expect(result).to eq(0)
  end
  
  it 'should return 0 for a list containing 0' do
    s = Sum.new
    result = s.calculate([0])
    
    expect(result).to eq(0)
  end
  
  it 'should return 1 for a list containing 1' do
    s = Sum.new
    result = s.calculate([1])
    
    expect(result).to eq(1)
  end
  
  it 'should return 2 for a list containing 1 and 1' do
    s = Sum.new
    result = s.calculate([1,1])
    
    expect(result).to eq(2)
  end
  
  it 'should return 20 for a list containing 2,2,2,2,2,2,2,2,2 and 2' do
    s = Sum.new
    result = s.calculate([2,2,2,2,2,2,2,2,2,2])
    
    expect(result).to eq(20)
  end
end
```


Step 2
----------

```ruby
class Sum
  
  def calculate(arr)
    result = 0
    index = 0

    while index < arr.size
     result += arr[index]
     index += 1
    end
    result
  end
  
end
```


Step 3
----------




Step 4
-----------


```ruby

```

Step 5
-----------



```ruby

```

Step 6
-----------



```ruby

```


Step 7
--------------



```ruby

```

Step 8
----------------



```ruby

```



Step 9
-------------



```ruby

```

Step 10
--------------



```ruby

```

Step 11
-----------



Step 12
------------


```ruby

```



Summary
=========
-----------

In this article you learned about 