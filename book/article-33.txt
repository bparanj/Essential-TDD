Problem #2

Counting

Problem Statement
=========
---------------------------

Implement a method called my_count that takes a number and an array of numbers and returns the count representing the total number of elements in the array that is equal or greater than the given number.

Problem Domain Analysis
=========
---------

my_count(n, a)

n = 10
a = [2, 7, 10, 15, 25]

The result in this case = 3, since there are only three numbers 10, 15 and 25 that are equal or above 10. In the irb:

```ruby
a.count{|x| x >= 10}
=> 3
```

We need to implement our version of the Ruby's count method called my_count. In this irb console session we only focus on specifying what needs to be done. The details of counting such as how many elements are in the list to be counted, when we need to terminate the loop etc has been hidden inside the count method. As you already know, what needs to be done is the focus of the problem domain analysis.

Solution Domain Analysis
=========
---------

Diagram goes here.

Table goes here.

Steps to Solve the Problem
=========

while < n numbers have been examined do
  1. Read the number
  2. If current number satisfies the condition then add one to count.
end

Algorithm
=========

1. Read the number of elements to be processed.
2. Initialize the count to 0
3. While there are still elements to be processed repeatedly do:
   a) Read the number
   b) If it satisfies the condition (>= 10) then add one to count.
4. Return the total number of elements that satisfies the condition.

count = 0
i = 0

while i < n do

end

i < n is the terminating condition.

Consideration of the problem at its lowest limit (i.e., n=0) leads to a mechanism that can be extended to larger values of n by simple repetition. This is a very common technique in algorithm design.

Discussion
=========
---------

AAA
Working Backwards
Scaffold

When to use Priority Transformation Premise
When to use algorithm depicted in flow chart and different tools for different situations.
Transformation Priority Premise is not a silver bullet.
  
Logical Design
=========
---------------------------
  
1. Read n and the array
2. Take the first element in the array
3. Check if element x >= n

    Yes --> Increment counter

4. Go to the next element

Terminating Condition
=========
---------------------------


Initial Condition
=========
---------------------------
index = 0 
count = 0

Pseudo Code
=========
---------------------------

while index < (size of array - 1)
  extract the element from the array
  compare --> increment counter if yes
end

return count



Steps
=========
---------------------------

Step 1
-------


```ruby
require_relative 'finds_equal_greater'

describe FindsEqualGreater do
  it "should return 1 for 0, [0]" do
    equal_greater = FindsEqualGreater.new
    
    result = equal_greater.count(0, [0])
    
    expect(result).to eql(1)
  end
  
  it "should return 0 for 1, [0]" do
    equal_greater = FindsEqualGreater.new
    
    result = equal_greater.count(1, [0])
    
    expect(result).to eql(0)
  end
  
  it "should return 2 for 1, [1,1]" do
    equal_greater = FindsEqualGreater.new
    
    result = equal_greater.count(1, [1,1])
    
    expect(result).to eql(2)
  end
  
  
  it "should return 5 for 3, [1,1,2,3,4,3,6,6,1]" do
    equal_greater = FindsEqualGreater.new
    
    result = equal_greater.count(3, [1,1,2,3,4,3,6,6,1])
    
    expect(result).to eql(5)
  end
  
end
```


Step 2
----------

```ruby
class FindsEqualGreater
  def count(num, array)
    index = 0
    count = 0
    
    while index < array.size
      count += 1 if array[index] >= num
      index += 1
    end

    count
  end
end
```


Step 3
----------



Step 4
-----------


```ruby

```

Step 5
-----------



```ruby

```

Step 6
-----------



```ruby

```


Step 7
--------------



```ruby

```

Step 8
----------------



```ruby

```



Step 9
-------------



```ruby

```

Step 10
--------------



```ruby

```

Step 11
-----------



Step 12
------------


```ruby

```



Summary
=========
-----------

In this article you learned about 